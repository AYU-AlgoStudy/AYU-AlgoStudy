## 1주차 1번 문제 백준 1260번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1260


### 개념 정리
> DFS 란 무엇인가?
``` DFS: 깊이 우선 탐색
	*재귀 호출 사용*
	1) 방문 노드 검사
	2) 문제에서 지정한 기능 수행
	3) 연결된 다음 노드 검사

	*그래프가 양방향 간선인 경우*
	3-1) 다음 노드가 이전 노드인 경우에는 생략 (continue)

	4) (3)의 조건 만족 시 (다음 노드 미방문) 다음 노드로 진행 DFS 재귀 호출 (다음 노드, 현재 노드)
```
---
> BFS 란 무엇인가?
``` BFS: 너비 우선 탐색
	*Queue 사용*
	1) 시작 노드를 queue에 추가 
	2) 방문 처리
	3) Queue가 빌 때 까지 아래 동작 반복 (Queue는 선입 선출 이기에 너비 우선으로 처리)
		- queue.front() 확인 및 꺼내기 queue.pop()
		- 현재 정점과 연결된 다음 정점 확인
		- 미방문 상태일 경우 방문 처리 흐 queueu.push(next) 로 queue에 추가
```

> 문제 풀이 과정에서 개선점

	1. `<vector>` 사용이 아직 미숙 
		- vector 배열을 외부에 선언해 두고 내부에서 사용전에 초기화 하는 로직 숙지가 아쉬움 (assign, resize의 차이점을 몰랐음)

	2. `DFS` 에서 V, E 의 구분이 미숙 
		- 간선은 정점 + 1개로 이루어지지만 초반 설계에서 정점을 활용하지 않고 간선으로 시작해서 결과 값이 계속 E 수 만큼 나옴

		- 초반 설계에서는 배열을 `E x 2` 형태로만 생각하여서 각 V 에 연결된 E 를 제대로 파악하지 못했음 
		- 양방향 간선을 제대로 입력하지 못했음 (2) 의 문제점과 유사 -> DFS 개념이 미숙

	3. `BFS` 는 그래프를 정렬 해야하는 점을 모름.
		- 정렬 하지않아서 DFS 방식으로 계속 탐색되었음.

### 총평
> 문제가 어렵기 보다는 DFS 와 BFS 에 대한 정확한 개념이 없어서 개념 숙지에서 시간을 더욱 많이 들어간 문제.

> 참고자료: 
> https://bubblebubble.tistory.com/59

---

## 1주차 2번 문제 백준 1991번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1991


### 개념 정리
> map & pair 자료 구조
```
	1) map 자료 구조는 [key : value] 형태로 자료를 저장하는 자료구조이다. Key 타입과 Value 타입이 같지 않아도 된다.
	2) pair 자료구조는 <value1, value2> 형태로 값을 저장하는 자료구조이다. 주로 좌표값에 주로 사용된다.
	3) 트리는 이진 트리 구조이며 부모 노드 하나가 최대 2개의 자식 노드를 가질 수있다. 
	4) 트리 순회는 항상 Left -> Right 노드 순으로 탐색한다.

	*map 자료 구조 특성 상 각 노드가 가지는 자식 노드의 값을 쉽게 알 수 있다.*
	*pair 자료구조는 자식 노드 저장이 편리하다. 즉 map [key(부모노드) : value(pair<left, right>)] 와 같은 구조로 부모 노드와 연결된 자식
	노드를 쉽게 알 수 있게된다.*
	*전위, 중위, 후위 순회는 전부 Letf -> Right 순서로 탐색하고 출력 위치를 조정하여서 결정한다.*

```

> 문제 풀이 과정에서 개선점

	1. map 자료구조가 어떻게 값을 찾아오는지를 잘 숙지하고 있지 못했다.

### 총평
> 원래는 기존에 배운 연결리스트를 통해서 구현해야하는 문제인듯싶었지만, 새로운 자료구조를 사용하게 되어서 시간을 더 단축하게 될 수 있었고, 
여러가지 자료구조를 잘 알아두어야 한다고 생각이되었다. 기존 생각처럼 연결리스트를 사용하였다면 코드가 매우 길어지고 노드 삭제, 삽입 등이 필요하여서
매우 여러가지 매서드가 필요하겠지만, map 을 통해 이진 트리를 매우 간단히 구현이 가능했다.

> 참고자료: 
> https://breakcoding.tistory.com/205
> https://breakcoding.tistory.com/154

---

## 1주차 3번 문제 백준 2178번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/2178


### 개념 정리
> BFS 활용 문제
``` 배열에서 최단 거리를 찾을 때는 BFS를 사용해야한다. DFS와의 차이점은 너비를 우선으로 탐색하기에 최단 거리 탐색에 용이하다. 
	DFS의 경우 분기점 마다 끝까지 방문 후 다시 분기점으로 돌아와서 다른 경로로 탐색을 하지만, BFS의 경우는 그저 모든 노드만큼만 탐색하기에
	DFS에 비해 효율적으로 최단 경로를 구할 수 있습니다.
	BFS를 사용해서 거리를 탐색하는 방법으로는 거리를 계산할 dist 배열을 준비 이전 위치의 이동 값에 + 1을 더해서 새로운 위치의 이동 값을 생성해서 답 구하기 문제
```

> 문제 풀이 과정에서 개선점
``` 미로라는 특징 과 최단 거리라는 조건을 생각하지 않고, '탐색' 만 확인하고 무작정 DFS 구현을 하였다가 계속해서 값이 크게 나오는 오답이 생겼습니다.
	또한 BFS로 구현 후 최단 거리를 구하는 방법을 단순하게 변수의 증감으로만 구하려했지만, 2차원 배열을 사용해서 경로마다의 이동 거리를 표시해야하는 방법을 몰랐습니다.

	*문제를 풀기 전에 먼저 문제의 특성을 생각하기*
		- 경로의 특징을 알아야하는 문제 = DFS
		- 최단 거리를 구해야하는 문제 = BFS
```



### 총평
> 미로 탐색 문제의 전반적인 방법과 DFS와 BFS의 차이점을 명확하게 알게 해주는 문제였습니다.

> 참고자료: 
> https://breakcoding.tistory.com/205
> https://breakcoding.tistory.com/154
