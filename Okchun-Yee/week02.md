## 2주차 1번 문제 백준 1182번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1182

### 문제 풀이
> [백준/Silver/1182. 부분수열의 합/부분수열의 합.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Silver/1182.%E2%80%85%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98%E2%80%85%ED%95%A9/%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98%E2%80%85%ED%95%A9.cc)

### 개념 정리
> 백트래킹 & 브루트 포스 알고리즘 개념 정리
``` *브루트 포스* 는 "완전 탐색" 알고리즘으로 모든 경우의 수를
    전부 탐색해야하는 방식입니다. 
    
    *백트래킹* 은 모든 경우의 수를 탐색하는 '깊이 우선 탐색' 방식이지만 오답이라고 판단되면 다음 단계로 진행하는 것이 아닌 이전 단계로 돌아가 다른 루트를 찾아보는 방식입니다.

    이번 문제는 "백트래킹" 방식을 주로 사용해 풀었습니다. 재귀를 2가지를 호출하여 (포함 한다 / 포함 안한다) 다음 단계 탐색을 진행하고, 함수 종료 후에는 호출 위치로 돌아가기에 이전 상태로 돌아가게 됩니다. 
```

> 문제 풀이 과정에서 개선점
``` 처음 사용하는 백트래킹 알고리즘이기에 알아가는 시간이
    필요했고, 브루트 포스 알고리즘은 무조건 n 중 반복문만을 사용해야하는 줄 알았지만 재귀 함수를 통해서도 완전 탐색을 구현하는 법을 배웠습니다.
```

### 총평
> 브루트 포스 & 백트래킹 두 가지 방식의 "깊이 우선 방식의 완전 탐색을 이해하게 되는 문제였습니다. 

> 참고 자료
> https://buganddog.tistory.com/7
> https://eunsolsblog.tistory.com/entry/C-%EB%B0%B1%EC%A4%80-1182%EB%B2%88-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9

---

## 2주차 2번 문제 백준 1759번 

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1759

### 문제 풀이
> [백준/Gold/1759. 암호 만들기](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/1759.%E2%80%85%EC%95%94%ED%98%B8%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0/%EC%95%94%ED%98%B8%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0.cc)

### 개념 정리
> 백트래킹 개념 활용 문제
``` 1182번 문제에서 배웠던 "백트래킹" 개념을 활용한 문제였습니다. 
    먼저 가장 첫번째 조건으로는 알파벳 증가 형식의 배치였기에 문자배열을 사전순서로 정렬하였습니다.
    그리고 백트래킹 방식을 재귀함수로 구현하여 다음 단어를 현재 문자열에 추가하는 방식으로 4개 문자를 가진 단어를 만들었습니다.
    두번째 조건으로 "최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성" 이 있기에 모음 확인 함수를 만들어 모음과 자음의 수가
    조건에 부합하는 지 확인 -> 조건에 부합하면 출력하는 방식으로 문제를 풀이 하였습니다.

    단어를 생성할 때에는 브루트 포스로 완전 탐색으로 가능한 단어 조합을 전부 생성하고 추후 출력에서만 조건을 검사하는 방식으로 로직을
    설계 하였습니다.
```

> 문제 풀이 과정에서 개선점
``` 아직 재귀 구조를 완벽하게 이해하고 있지는 않은 것 같습니다. 또한 백트래킹 개념을 완전히 이해하지 못해 재귀 탐색에서 어떻게 백트래킹을 
    하는지 방법을 생각할 때 AI 도움을 받았습니다.
```

### 총평
> 백트래킹을 사용해 전체를 탐색하고 이후 조건을 추가하여 필터링을 하는 간단한 활용의 문제 였던 것 같습니다.

> 참고 자료
> 🚫

---

## 2주차 3번 문제 백준 1987번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1987

### 문제 풀이
> [백준/Gold/1987. 알파벳](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/1987.%E2%80%85%EC%95%8C%ED%8C%8C%EB%B2%B3/%EC%95%8C%ED%8C%8C%EB%B2%B3.cc)

### 개념 정리
> 백트래킹 & DFS + map 자료구조 + 미로탐색 알고리즘 개념 정리
``` 처음 문제를 보았을 때 DFS + 미로탐색을 베이스로 구현하고 map 자료 구조를 사용하여 알파벳 별로 TRUE / FALSE 를 검사하여
    알파벳 방문 처리, 배열 방문 처리를 진행할 생각이였습니다.
    알파벳 방문 여부를 통해 미리 가능성을 판단하고 백트래킹을 위해 DFS 진입 전에 방문 배열을 = true 로 지정
    DFS 종료 후 방문 배열을 다시 = false로 설정해 `상태 복원`을 진행합니다.
    이후 매 탐색 마다 탐색 최대 값을 전역 변수 `maxCnt`에 저장해 최대 탐색 횟수를 파악합니다.
```

> 문제 풀이 과정에서 개선점
``` 
    ``` `vector<vector<bool>> visited` 배열을 통한 방문 처리는 알파벳 방문처리에 의해 미리 막히기에 사용할 필요가 없었고,

        방문 횟수 계산 변수인 `int cnt` 를 전역 변수로 두어 방문 마다 증가 시키는 방법을 사용하려 했으나 단순한 증가 만으로는 최대 탐색
        횟수를 파악할 수 없기에 DFS 마다 증가 시키는 탐색 횟수 중 최댓값을 따로 저장하는 방식으로 변경. <- AI 지적 사항
```

### 총평
> 백트래킹 개념을 한번 더 활용하며 자세히 알 수 있는 문제였습니다.

> 참고 자료
> 🚫

---

## 2주차 4번 문제 백준 9663번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/9663

### 문제 풀이
> [백준/Gold/9663. N－Queen](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/9663.%E2%80%85N%EF%BC%8DQueen/N%EF%BC%8DQueen.cc)

### 개념 정리
> 백트래킹 활용
``` 경우의 수를 구하는 백트래킹 자체는 간단하지만 문제의 접근 방식이 매우 어려웠다.
    이차원 배열로 접근을 하게 되면 필연적으로 시간복잡도에서 막히게되므로 1차원 배열을 여러개 활용하는 접근 방식이 필요했다.
    1. 체스판에서 퀸은 가로 / 세로 / 좌하향 대각선 / 우하향 대각선 이렇게 4방향으로 이동 할 수 있다.
    2. 각 이동 방향 마다 1차원 배열을 생성한다
        - 세로: colChk[15] *배열의 크기는 N의 최대 크기*
        - 좌하향 대각선: digChk[0][29] *이차원 배열인 이유는 좌/우 대각선을 한개의 배열로 관리 하기 위함* *배열의 크기는 `2N - 1`*
        - 가로: DFS 탐색 Level을 row로 사용
    3. 탐색 조건 지정
        - 탐색 lv은 중복되지 않기에 각 행에는 한개의 퀸만 배치
        - 열 & 대각선 탐색은 반복문으로 N 만큼 탐색
            - 우하향 대각선 계산식: `x + y`
            - 좌하향 대각선 계산식: `(x - y) + (N - 1)`
    4. 종료 조건: 탐색 lv == N (행의 끝에 도달) => 경우의 수 증가 => 백트래킹
```

> 문제 풀이 과정에서 개선점
``` 무작정 이차원 배열로 시도 하였다가 시간복잡도에 걸렸서 다른 방식을 찾아보다 1차원 배열 방식을 발견하고 굉장히 놀라웠습니다. 
    요즘 문제를 풀면서 무조건 vector를 사용하는 집착이 있었는데 단순 배열만으로 이렇게 간단히 문제 해결을 하는걸 보고 반성하게 되었습니다.

    *대각선 계산식 중 좌하향 계산식을 틀리게 작성해서 오답 발생 1회* => 계산식 꼼꼼히 점검하기
```

### 총평
> 백트래킹 개념보다 문제의 접근방식이 더욱 어려웠던 문제, 1차원 배열을 활용하는 방법을 더욱 연습해야할 필요가 있습니다.

> 참고 자료
> https://www.acmicpc.net/board/view/157906
> https://jja2han.tistory.com/30

---

## 2주차 5번 문제 백준 14888번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/14888

### 문제 풀이
> [백준/Silver/14888. 연산자 끼워넣기](https://github.com/Okchun-Yee/CodingTestStudy/blob/26f9a2ae66ca78ae254f635b1163bd8fab45c12e/%EB%B0%B1%EC%A4%80/Silver/14888.%E2%80%85%EC%97%B0%EC%82%B0%EC%9E%90%E2%80%85%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0/%EC%97%B0%EC%82%B0%EC%9E%90%E2%80%85%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0.cc)

### 개념 정리
> 백트래킹 개념 + 중복연산 방지
``` 입력 받은 순서에 따라 배열에 연산자를 추가하고 숫자 배열과, 연산자 배열을 사용해 경우의 수를 찾아내는 방식을 사용했습니다.
    재귀 조건으로 중복 인덱스 인데 이전 연산자를 방문하지 않았다면 생략하여 중복 수열을 방지하였습니다.

    연산자 배열을 생성 후에는 중복 수열 방지를 위해 정렬
```

> 문제 풀이 과정에서 개선점
``` 백트래킹을 아직 완벽하게 다루지 못하는 것같습니다. 항상 재귀 조건을 설계할때 어려움을 겪음
```

### 총평
> 백트래킹 활용 문제, 재귀 조건과 연산자 접근에 대해 생각해야하는 문제

> 참고 자료
> 🚫

---

## 2주차 6번 문제 백준 2580번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/2580

### 문제 풀이
> [백준/Gold/2580. 스도쿠/스도쿠.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/95e8502d5fdc667602cf8053e8542760037a891e/%EB%B0%B1%EC%A4%80/Gold/2580.%E2%80%85%EC%8A%A4%EB%8F%84%EC%BF%A0/%EC%8A%A4%EB%8F%84%EC%BF%A0.cc)

### 개념 정리
> N-Qeen 문제와 동일한 배열을 사용해 시간복잡도 줄이기 + 백트래킹
``` 스도쿠는 9 X 9의 2차원 배열 보드판을 사용한다. 하지만 모든 보드판을 전부 탐색하기에는 메모리 낭비가 심하기에
    3개의 배열을 사용하여 탐색해 `O(9^E) | E = 보드판 빈칸 수` 의 시간 복잡도를 가지게 만들었습니다.
    row 배열로 [row][num] 의 좌표로 해당 row 에 num 이 있는지 
    col 배열로 [col][num] 의 좌표로 해당 col 에 num 이 있는지
    box 배열로 [INDEX][num] 의 좌표로 해당 INDEX 에 num 이있는지 *INDEX = (row/3)*3 + (col/3)*
    총 3번의 검사를 통해서 없는 num과 들어갈 수 있는 num을 가려냅니다.
    스도쿠 보드 입력에서 숫자가 입력 될떄마다 해당 하는 배열을 전부 `TRUE` 로 표시 이후 백트래킹 탐색에서 false 인 배열 위치만 가려냅니다.
```

> 문제 풀이 과정에서 개선점
``` 설계에서 백트래킹 과정에서 왜 board 판에 넣은 num을 상태 원복 과정에서 다시 제거해야하는지 이해하지 못했습니다. 왜냐면 최종 출력에서
    보여주어야하는데 왜 다시 0으로 만드는거지 생각했지만 이는 백트래킹을 이해하지 못해서 든 생각이였습니다. 왜냐면 방금 시도한 위치에 다른 num을 시도해야하는데 0으로 되돌리지 않으면 시도 할 수 없기 때문입니다. 
    제가 한 걱정 => 결과를 잃어 버리는거 아닌가? 는 최종 출력을 "종료 조건" 시점에서 출력하면 모든 결과가 들어잇는 상태로 출력이 되는 간단한 걱정이였습니다. 

    *오답 1회*
    - 첫 제출 로직은 종료 조건에 `return`으로 종료 했습니다. 이는 일반적인 백트래킹 기법에서는 정답을 찾고 -> 다른 정답을 찾아보는 브루트 포스의 방식으로 문제가 없지만 스도쿠의 경우 만약 모든 입력이 '0' 이 들어온다면 (6.67 x 10²¹ 가지) 매우 많은 경우의 수가 생기기에 첫 정답에서 프로그램을 강제로 종료 시킬 필요가 잇었습니다. 스도쿠 문제는 모든 정답을 찾을 필요가 없기 때문에 

    #include <cstdlib> 헤더의 exit(0); 을 사용해 정답 시 강제 종료로 해결하였습니다.
```

### 총평
> 백트래킹이 꼭 완전 탐색이 아니라는 점을 알게 해준 문제, 배열 활용이 한층 늘어난것 같습니다.

> 참고 자료

--- 

## 2주차 7번 문제 백준 11725번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/11725

### 문제 풀이
> [백준/Silver/11725. 트리의 부모 찾기/트리의 부모 찾기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/56b946cdfb0bc98130b5c5d89ed88769b79f166c/%EB%B0%B1%EC%A4%80/Silver/11725.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EB%B6%80%EB%AA%A8%E2%80%85%EC%B0%BE%EA%B8%B0/%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EB%B6%80%EB%AA%A8%E2%80%85%EC%B0%BE%EA%B8%B0.cc)

### 개념 정리
> DFS 기본 활용 정리
``` DFS 기본적인 활용
    DFS 구현은 쉬웠고 자식 노드에 연결된 부모 노드의 출력 조절을 DFS 탐색 시 마다 배열의 Index를 현재 탐색 중인 자식 노드로 지정
    값을 이전 노드(부모 노드)로 할당 후 출력을 순서대로 하면 2번 ~ N번 노드까지 탐색이 완료
```

> 문제 풀이 과정에서 개선점
``` 첫 시도는 이진 트리 탐색을 시도하였으나, 단순한 배열을 사용해 출력 순서만 조절하는 문제였습니다.
    탐색 순서 변경을 시도하려 했으나 이 방식은 비효율적

    *추가로 `cout << endl` 문법을 사용하면 시간초과 `cout << "\n"` 을 사용하면 시간 초과 X*
```

### 총평
> 🤨 | DFS 탐색 순서 조절에 매몰되어 쉬운 문제를 조금 어렵게 돌아갔습니다.

> 참고 자료
> https://www.acmicpc.net/board/view/156992 (시간 초과 문제 해결)

---

## 2주차 8번 문제 백준 5639번 

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/5639

### 문제 풀이
> [백준/Gold/5639. 이진 검색 트리](https://github.com/Okchun-Yee/CodingTestStudy/tree/aee0389d2958d003f4664409daa22e35c72c5054/%EB%B0%B1%EC%A4%80/Gold/5639.%E2%80%85%EC%9D%B4%EC%A7%84%E2%80%85%EA%B2%80%EC%83%89%E2%80%85%ED%8A%B8%EB%A6%AC)

### 개념 정리
> 이진 탐색 트리의 특징과 재귀 함수를 이용한 DFS의 특징 정리
``` 문제의 입력값은 "전위 순회" 그리고 모든 원소가 정렬되어 있는 "이진 탐색 트리" 라는 것을 통해서 해당 문제는 
    전위 순회 결과를 통한 이진 탐색 트리 생성 -> 해당 트리 후위 순회라는 풀이를 가진다는 것을 알 수 있습니다. 각 서브 트리의 후위 순회는 전위 순회의 역순 이기에 이를 이용 => 재귀 호출과 종료는 역순
        1. 재귀 DFS를 통해서 이진 탐색 트리 생성
        2. 함수 종료 지점에 자신의 값을 출력
    이 2가지의 방식으로 실제로 이진 탐색 트리를 생성하지 않고 전위 순회 결과만으로 후위 순회 결과 출력이 가능했습니다. 

    --- 

    이진 탐색 트리를 생성하는 과정으로는 전위 순회는 첫번쨰 값이 서브 트리의 root 이기에 
        1. 항상 현재 노드의 값을 서브 트리의 root로
        2. 값이 root 보다 커지는 지점 = split (오른쪽 서브 트리 시작 지점) 을 탐색
        3. 왼쪽 서브 트리 인수: (start + 1, slpit - 1) *탐색 레벨 + 1, 오른쪽 서브트리 시작 위치 - 1*
        4. 오른쪽 서브 트리 인수: (split, end) *탐색 레벨 = 오른쪽 서브트리 시작점, 전위 순회 결과값의 끝*
```

> 문제 풀이 과정에서 개선점
``` 입력의 횟수가 지정되지 않은 문제를 처음 풀어보았기에 살짝 헤메는 지점이 있었지만, 
    그 외 문제의 설계 자체는 어려움이 없었습니다. 처음에는 이진 트리를 직접 생성하려 하였지만 이진 탐색 트리라는 특성 덕분에 실제 트리
    생성 없이 재귀 호출 만으로 풀이가 가능했습니다.
```

### 총평
> 재귀의 특성을 잘 이해하고 있어야 효율적으로 풀이가 가능한 문제, 이진 탐색 트리를 직접 생성해보는것도 도움이 되었겠지만 효율성을 생각해서 재귀로만 구현 하였습니다.

> 참고 자료
> 

---

## 2주차 9번 문제 백준 19535번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/19535

### 문제 풀이
> [백준/Gold/19535. ㄷㄷㄷㅈ/ㄷㄷㄷㅈ.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/a2879bebb3515c83035ae78ec86b9374e3dc28ec/%EB%B0%B1%EC%A4%80/Gold/19535.%E2%80%85%E3%84%B7%E3%84%B7%E3%84%B7%E3%85%88/%E3%84%B7%E3%84%B7%E3%84%B7%E3%85%88.cc)

### 개념 정리
> 각 노드의 E 정보 만으로 트리의 개수 파악
```  # 'ㅈ' 트리 카운팅 원리 : 노드 중심
    하나의 중심 노드 - 3개의 간선
    1. 임의의 노드 i에 연결된 간선의 총개수 (k)
    2. i 노드 중심으로 'ㅈ' 트리 구성을 위해서는 k 개의 간선 중 3개를 선택 
    => (kC3)
    3. 이 계산을 1번 ~ N번 까지에 대해 각각 수행 후 모든 결과 더하기
```

```
    # 'ㄷ' 트리 카운팅 원리 : 간선 중심
    4개의 노드가 선형으로 이어진 경로 - 중심 간선 기준으로 계산
    1. 임의의 간선 (u, v)
    2. 해당 간선을 중심으로 u의 이웃, v의 이웃을 하나씩 선택
        - u에 연결된 다른 간선의 수: `degree(u) - 1` (v로 가는 간선 제외)
        - v에 연결된 다른 간선의 수: `degree(v) - 1` (u로 가는 간선 제외)
    3. 간선 (u, v) 가 만들 수 있는 'ㄷ' 트리의 수 
    = `(degree(u) - 1) * (degree(v) - 1)`
    4. 모든 간선에 대해 수행 후 결과 전부 더하기
```

> 문제 풀이 과정에서 개선점

> 오답 1) 첫 시도한 N, G 트리의 개수를 세는 로직의 오류

> 첫 번째 DFS(go 함수)를 통해 모든 노드의 **깊이(depth)**와 **자식 수(childArr)**를 계산하는 것입니다.
이 값들은 트리의 루트를 1번으로 고정했을 때만 의미 BUT, 루트가 누군지는 관계없이 각 노드의 전체 차수에 의해서 결정하여야함. 
    
        > 'G' 트리 계산 오류
        `gNum += combination(childArr[next], 2);`: 이 코드는 'G' 트리의 정의와 아무런 관련이 없는 잘못된 값을 더하고 있습니다.
        `gNum += combination(childArr[current], 3);`: 이 코드는 childArr(자식 수)을 기준으로 계산합니다. 
        하지만 'G' 트리는 부모쪽 간선을 포함한 전체 차수(tree[current].size())를 기준으로 계산해야 합니다. 
        예를 들어, 중간에 있는 노드는 부모 간선이 빠져있어 degree보다 childArr 1 작으므로 cntD가 더 적게 계산됩니다.

        > 'D' 트리 계산 오류
        `i`f (depth[current] >= 4) { cntD += 1; }`: 깊이를 이용한 이 계산은 'D' 트리를 세는 올바른 방법이 아니며, 불필요한 값을 더합니다.
        `cntD += childArr[next] * (childArr[current] - 1);`: 올바른 'D' 트리 계산은 모든 간선 (u, v)에 대해 (degree(u)-1) * (degree(v)-1)을 더하는 것입니다. 
        이 코드는 degree가 아닌 childArr 사용하고, childArr[next]에서 1을 빼지 않는 등 공식이 틀렸습니다.
        
<img width="329" height="81" alt="image" src="https://github.com/user-attachments/assets/5c1a7ceb-9937-4cde-a3f1-10ae533da540" />

> 오답 2) 근본적인 접근 방식 오류

> D & G 트리를 계산 하는 상황 자체는 맞게 설계하였으나 이를 구현하기 위해 노드별 깊이와 노드별 자식 노드를 파악하는 DFS 1회
    
        그 후 각 트리의 모양을 계산 하는 DFS 2회로 구성 하였으나 이 부분의 시간복잡도가 아예 범위를 벗어나있었기에 바로 오답처리가 되었습니다.
        구조를 아예 변경 하였습니다. 각 정점의 간선으로 부터 차수의 수를 이용한 계산으로 변경
        # 'G' 트리 계산
        for (int i = 1; i <= N; ++i) {
            cntG += combination3(tree[i].size());
        }
        # 'D' 트리 계산
        for (const auto& edge : edges) {
            long long u = edge.first;
            long long v = edge.second;

            cntD += (long long)(tree[u].size() - 1) * (long long)(tree[v].size() - 1);
        }
<img width="432" height="69" alt="image" src="https://github.com/user-attachments/assets/97e63249-1ac8-45ff-8df0-3878776cd0d8" />


### 총평
> 생각 외어 어렵게 접근했던 문제이지만 막상 정답을 확인하게 되니 너무 간단해서 오히려 진이 빠진것 같다. 요즘 너무 탐색에만 몰두 하다보니 모든 문제를 탐색을 사용하혀는 안좋은 습관이 생긴 것같다. 항상 문제의 접근 방식에 대해서 다양한 시각에서 봐야하는 점을 배우게 된 문제인것 같다. 

> 참고 자료
> https://glanceyes.com/entry/BOJ-%EB%B0%B1%EC%A4%80-19535%EB%B2%88-%E3%84%B7%E3%84%B7%E3%84%B7%E3%85%88 - 오류 발생의 원인

---

## 2주차 10번 문제 백준 1261번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1261

### 문제 풀이
> [백준/Gold/1261. 알고스팟/알고스팟.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/bfab2d2fbbceabefbbf9271310b00463bae7feeb/%EB%B0%B1%EC%A4%80/Gold/1261.%E2%80%85%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F/%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F.cc)

### 개념 정리
> 0-1 BFS 와 deque 자료구조
``` 해당 문제는 미로탐색과 최단거리 문제입니다 그러나 단순한 방식이 아닌 어떤 경로는 0(빈방), 어떤 경로는 1(벽) 으로 경로마다 **비용** 을
    가지는 문제입니다. 그렇다면 우리는 최소 비용을 사용하는 최단 거리를 찾기 위해서는 경로의 비용에 따라 탐색의 우선 순위를 두어야합니다.
        일반적인 BFS에서 사용하는 자료구조인 **Queue** 의 경우 비용을 고려하지 않고 탐색을 하는 **FIFO** 이기 때문에 우선 순위가 낮은 비용 1의 경로를 우선 순위가 높은 비용 0 인 경로보다 먼저 탐색을 하는 경우가 생기게 됩니다. 이러한 점을 해결하기 위해 **0-1 BFS** 와 **deque** 자료구조를 사용할 것입니다.

    > 0-1 BFS 

    가중치가 0과 1로만 이루어진 그래프에서 최단 경로를 찾기 위해서 사용되는 BFS. **O(V + E)** 의 시간 복잡도를 가진다.
    1. deque의 front 에서 현재 노드 탐색
    2. 인접 노드 탐색
    3. 현재 노드까지 가중치 + 다음 노드의 가중치 갱신
    4. 다음 노드의 가중치가 '0' 이면 **push_front** / 다음 노드의 가중치가 '1' 이면 **push_back** 으로 우선 순위 조정
    5. 목표 도달까지 반복

    > deque 자료구조 
    queue의 양쪽 끝 (앞 / 뒤) 에서 삽입 & 삭제를 허락하는 자료구조
    But) 중간 삽입 & 삭제는 불가
```

> 문제 풀이 과정에서 개선점
``` 일반적인 BFS 생각하고 최단거리 + 미로탐색 알고리즘을 구현 후 가중치가 1인 경우에만 비용 증가하도록 하였지만 이는 최단거리는 찾아도
    최소 비용을 찾을 수는 없었습니다. 그렇기에 최소 비용을 위해 0-1 BFS 라는 알고리즘을 알게 되었고, Queue -> Deque으로 변경해 문제를
    해결하였습니다. 
```

### 총평
> 새로운 자료구조와 알고리즘을 배울 수 있었습니다. 미로탐색에서 가중치를 계산하는 방식을 배웠습니다.

> 참고 자료
> https://velog.io/@9e0na/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%8D%B1DEQUE
> https://nicotina04.tistory.com/168

---

## 2주차 11번 문제 백준 13913번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/13913

### 문제 풀이
> [백준/Gold/13913. 숨바꼭질 4/숨바꼭질 4.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/19674184b65081f6411e8a2c7ffa491a093fab7a/%EB%B0%B1%EC%A4%80/Gold/13913.%E2%80%85%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88%E2%80%854/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88%E2%80%854.cc)

### 개념 정리
> 최단 거리 역추적
``` 처음에는 브루트 포스 재귀함수로 접근하였습니다. 그러나 브루트 포스 재귀 방식은 명확한 종료 조건을 만들기가 힘들고 무한 루프에 빠지는
    경우가 너무 많아서 고민하던 중 **최단거리 역추적** 이라는 방식을 알게되었습니다.

        > 최단거리 역추적
        
        기본적으로 BFS 방식으로 탐색을 진행 이때 탐색하는 경로 (자식노드, 부모노드) 정보를 배열에 저장 후 
        탐색이 종료되면 목표지점 -> 출발 지점까지 노드를 역으로 추적하는 방식

        # EX) path[child] = parent; 
    해당 방식으로 3가지 경우(-1, +1, *2)를 탐색, 탐색 LV과 경로를 계속해서 저장해 나갑니다.
    이때 탐색 LV은 BFS 이기에 최단거리를 가지게됩니다.
    탐색이 종료 후 목표 -> 출발 까지 부모노드를 계속해서 따라가며 배열에 저장 후 출력은 출발 -> 목표 형식이기에 배열을 뒤집은 후 출력
```

> 문제 풀이 과정에서 개선점
``` 브루트 포스의 종료 조건을 명확하게 만들지 못해 계속해서 무한 루프에 빠지게 되었습니다. 
    이후 최단거리 역추적 BFS 방식으로 넘어왔지만 (-1, +1, *2) 3가지 경우 탐색을 원할하게 만들지 못했습니다. 
```

### 총평
> 새로운 알고리즘 **최단거리 역추적** 을 배우게 되었습니다. 또한 경우의 수로 BFS를 탐색하는 방법을 한단계 더 배우게 되었습니다.

> 참고 자료
> https://velog.io/@flowersayo/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%97%AD%EC%B6%94%EC%A0%81

---

### 주차 review
> 제일 어려웠던 문제 : BOJ 19535번
    - 이유: 트리를 계속 Root가 존재하는 트리로 생각하여서 트리 탐색을 2번의 DFS 탐색을 통해서 트리 구조를 파악하여 노드 계산을 시도 했기에 
    계속해서 오답만 맞이해야했습니다. 단순히 노드간 간선의 관계만으로 별다른 탐색 없이 해결 가능한 문제였는데 너무 특정 탐색기법에 매몰

> 새로이 알게된 알고리즘
    - 0-1 BFS, 최단거리 역추적, deque 자료구조, 이진 탐색트리의 특징