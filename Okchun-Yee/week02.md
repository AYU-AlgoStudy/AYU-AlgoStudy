## 2주차 1번 문제 백준 1182번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1182

### 문제 풀이
> [백준/Silver/1182. 부분수열의 합/부분수열의 합.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Silver/1182.%E2%80%85%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98%E2%80%85%ED%95%A9/%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98%E2%80%85%ED%95%A9.cc)

### 개념 정리
> 백트래킹 & 브루트 포스 알고리즘 개념 정리
``` *브루트 포스* 는 "완전 탐색" 알고리즘으로 모든 경우의 수를
    전부 탐색해야하는 방식입니다. 
    
    *백트래킹* 은 모든 경우의 수를 탐색하는 '깊이 우선 탐색' 방식이지만 오답이라고 판단되면 다음 단계로 진행하는 것이 아닌 이전 단계로 돌아가 다른 루트를 찾아보는 방식입니다.

    이번 문제는 "백트래킹" 방식을 주로 사용해 풀었습니다. 재귀를 2가지를 호출하여 (포함 한다 / 포함 안한다) 다음 단계 탐색을 진행하고, 함수 종료 후에는 호출 위치로 돌아가기에 이전 상태로 돌아가게 됩니다. 
```

> 문제 풀이 과정에서 개선점
``` 처음 사용하는 백트래킹 알고리즘이기에 알아가는 시간이
    필요했고, 브루트 포스 알고리즘은 무조건 n 중 반복문만을 사용해야하는 줄 알았지만 재귀 함수를 통해서도 완전 탐색을 구현하는 법을 배웠습니다.
```

### 총평
> 브루트 포스 & 백트래킹 두 가지 방식의 "깊이 우선 방식의 완전 탐색을 이해하게 되는 문제였습니다. 

> 참고 자료
> https://buganddog.tistory.com/7
> https://eunsolsblog.tistory.com/entry/C-%EB%B0%B1%EC%A4%80-1182%EB%B2%88-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9

---

## 2주차 2번 문제 백준 1759번 

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1759

### 문제 풀이
> [백준/Gold/1759. 암호 만들기](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/1759.%E2%80%85%EC%95%94%ED%98%B8%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0/%EC%95%94%ED%98%B8%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0.cc)

### 개념 정리
> 백트래킹 개념 활용 문제
``` 1182번 문제에서 배웠던 "백트래킹" 개념을 활용한 문제였습니다. 
    먼저 가장 첫번째 조건으로는 알파벳 증가 형식의 배치였기에 문자배열을 사전순서로 정렬하였습니다.
    그리고 백트래킹 방식을 재귀함수로 구현하여 다음 단어를 현재 문자열에 추가하는 방식으로 4개 문자를 가진 단어를 만들었습니다.
    두번째 조건으로 "최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성" 이 있기에 모음 확인 함수를 만들어 모음과 자음의 수가
    조건에 부합하는 지 확인 -> 조건에 부합하면 출력하는 방식으로 문제를 풀이 하였습니다.

    단어를 생성할 때에는 브루트 포스로 완전 탐색으로 가능한 단어 조합을 전부 생성하고 추후 출력에서만 조건을 검사하는 방식으로 로직을
    설계 하였습니다.
```

> 문제 풀이 과정에서 개선점
``` 아직 재귀 구조를 완벽하게 이해하고 있지는 않은 것 같습니다. 또한 백트래킹 개념을 완전히 이해하지 못해 재귀 탐색에서 어떻게 백트래킹을 
    하는지 방법을 생각할 때 AI 도움을 받았습니다.
```

### 총평
> 백트래킹을 사용해 전체를 탐색하고 이후 조건을 추가하여 필터링을 하는 간단한 활용의 문제 였던 것 같습니다.

> 참고 자료
> 🚫

---

## 2주차 3번 문제 백준 1987번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/1987

### 문제 풀이
> [백준/Gold/1987. 알파벳](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/1987.%E2%80%85%EC%95%8C%ED%8C%8C%EB%B2%B3/%EC%95%8C%ED%8C%8C%EB%B2%B3.cc)

### 개념 정리
> 백트래킹 & DFS + map 자료구조 + 미로탐색 알고리즘 개념 정리
``` 처음 문제를 보았을 때 DFS + 미로탐색을 베이스로 구현하고 map 자료 구조를 사용하여 알파벳 별로 TRUE / FALSE 를 검사하여
    알파벳 방문 처리, 배열 방문 처리를 진행할 생각이였습니다.
    알파벳 방문 여부를 통해 미리 가능성을 판단하고 백트래킹을 위해 DFS 진입 전에 방문 배열을 = true 로 지정
    DFS 종료 후 방문 배열을 다시 = false로 설정해 `상태 복원`을 진행합니다.
    이후 매 탐색 마다 탐색 최대 값을 전역 변수 `maxCnt`에 저장해 최대 탐색 횟수를 파악합니다.
```

> 문제 풀이 과정에서 개선점
``` 
    ``` `vector<vector<bool>> visited` 배열을 통한 방문 처리는 알파벳 방문처리에 의해 미리 막히기에 사용할 필요가 없었고,

        방문 횟수 계산 변수인 `int cnt` 를 전역 변수로 두어 방문 마다 증가 시키는 방법을 사용하려 했으나 단순한 증가 만으로는 최대 탐색
        횟수를 파악할 수 없기에 DFS 마다 증가 시키는 탐색 횟수 중 최댓값을 따로 저장하는 방식으로 변경. <- AI 지적 사항
```

### 총평
> 백트래킹 개념을 한번 더 활용하며 자세히 알 수 있는 문제였습니다.

> 참고 자료
> 🚫

---

## 2주차 4번 문제 백준 9663번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/9663

### 문제 풀이
> [백준/Gold/9663. N－Queen](https://github.com/Okchun-Yee/CodingTestStudy/blob/6c54903ec49b309cb286fad74abac986cc737a01/%EB%B0%B1%EC%A4%80/Gold/9663.%E2%80%85N%EF%BC%8DQueen/N%EF%BC%8DQueen.cc)

### 개념 정리
> 백트래킹 활용
``` 경우의 수를 구하는 백트래킹 자체는 간단하지만 문제의 접근 방식이 매우 어려웠다.
    이차원 배열로 접근을 하게 되면 필연적으로 시간복잡도에서 막히게되므로 1차원 배열을 여러개 활용하는 접근 방식이 필요했다.
    1. 체스판에서 퀸은 가로 / 세로 / 좌하향 대각선 / 우하향 대각선 이렇게 4방향으로 이동 할 수 있다.
    2. 각 이동 방향 마다 1차원 배열을 생성한다
        - 세로: colChk[15] *배열의 크기는 N의 최대 크기*
        - 좌하향 대각선: digChk[0][29] *이차원 배열인 이유는 좌/우 대각선을 한개의 배열로 관리 하기 위함* *배열의 크기는 `2N - 1`*
        - 가로: DFS 탐색 Level을 row로 사용
    3. 탐색 조건 지정
        - 탐색 lv은 중복되지 않기에 각 행에는 한개의 퀸만 배치
        - 열 & 대각선 탐색은 반복문으로 N 만큼 탐색
            - 우하향 대각선 계산식: `x + y`
            - 좌하향 대각선 계산식: `(x - y) + (N - 1)`
    4. 종료 조건: 탐색 lv == N (행의 끝에 도달) => 경우의 수 증가 => 백트래킹
```

> 문제 풀이 과정에서 개선점
``` 무작정 이차원 배열로 시도 하였다가 시간복잡도에 걸렸서 다른 방식을 찾아보다 1차원 배열 방식을 발견하고 굉장히 놀라웠습니다. 
    요즘 문제를 풀면서 무조건 vector를 사용하는 집착이 있었는데 단순 배열만으로 이렇게 간단히 문제 해결을 하는걸 보고 반성하게 되었습니다.

    *대각선 계산식 중 좌하향 계산식을 틀리게 작성해서 오답 발생 1회* => 계산식 꼼꼼히 점검하기
```

### 총평
> 백트래킹 개념보다 문제의 접근방식이 더욱 어려웠던 문제, 1차원 배열을 활용하는 방법을 더욱 연습해야할 필요가 있습니다.

> 참고 자료
> https://www.acmicpc.net/board/view/157906
> https://jja2han.tistory.com/30