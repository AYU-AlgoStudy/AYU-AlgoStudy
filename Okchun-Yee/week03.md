## 3주차 1번 문제 BOJ 18430번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/18430

### 문제 풀이
> [백준/Gold/18430. 무기 공학/무기 공학.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/3ad2bf876ded50e92e396760b9f2f3eace1a86f4/%EB%B0%B1%EC%A4%80/Gold/18430.%E2%80%85%EB%AC%B4%EA%B8%B0%E2%80%85%EA%B3%B5%ED%95%99/%EB%AC%B4%EA%B8%B0%E2%80%85%EA%B3%B5%ED%95%99.cc)

### 개념 정리
> **백트래킹 활용**

    처음 문제에 접근 할때는 단순하게 미로탐색 알고리즘을 사용하려했다. 
    결과적으로 미로탐색처럼 위치를 미리 배열로 지정하여서 Index에 따라서 위치를 가져오는 방식은 맞았다. 
    그러나 간단한 미로탐색처럼 x, y 4방향 탐색이 아닌 미리 2차원 배열을 통해서 4가지의 부메랑 모양을 만드는 방식이였다.

    이후 중심노드 -> 날개 노드로 접근 할 때 날개 노드의 Index (x1, y1) (x2, y2)를 구해야하는데 이계산을 
    3가지 함수 (노드 확인, 노드 합 계산, 노드 상태복원) 에서 각각 switch-case문을 사용해 반복하였으나 비효율적이라고 생각 위에서 설명한
    배열에 미리 4가지의 모양을 넣어두는 방식으로 변경.
    
``` C++
# 기존 접근 방식
switch (idx)
 	{
 		// 1. (x, y-1) (x, y) (x+1, y)
 	case 0:
 		x1 = x;     y1 = y - 1;
 		x2 = x + 1; y2 = y;
 		break;
 		// 2. (x-1, y) (x, y) (x, y-1)
 	case 1:
 		x1 = x - 1; y1 = y;
 		x2 = x;     y2 = y - 1;
 		break;
 		// 3. (x-1, y) (x, y) (x, y+1)
 	case 2:
 		x1 = x - 1; y1 = y;
 		x2 = x;     y2 = y + 1;
 		break;
 		// 4. (x, y+1) (x, y) (x+1, y)
 	case 3:
 		x1 = x;     y1 = y + 1;
 		x2 = x + 1; y2 = y;
 		break;
 	default:
 		return;
 	}
```
``` C++ 
# 수정한 접근 방식
// 1. (x, y-1) (x, y) (x+1, y)
// 2. (x-1, y) (x, y) (x, y-1)
// 3. (x-1, y) (x, y) (x, y+1)
// 4. (x, y+1) (x, y) (x+1, y)
int dx[4][2] = { {0, 1}, {-1, 0}, {-1, 0}, {0, 1} };
int dy[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0} };

// 날개 Index 구하기
int x1 = x + dx[idx][0];
int y1 = y + dy[idx][0];
int x2 = x + dx[idx][1];
int y2 = y + dy[idx][1];
```

> **문제 풀이 과정에서 개선점 & 배운점**
    백트래킹 과정에서 경우의 수를 지정하는 것에 아직 약한 것같다. 이번 문제의 경우도 4가지 모양을 만드는 부분에서는 어려움이 없었지만
    마지막 결과가 잘 나오지 않았는데 이는 **추가하지 않는 경우** 를 고려하지 않았기에 생기는 오류였다.

    아직 눈에 보이는 경우의 수는 구현이 가능하지만 **추가하지 않는 경우**와 같은 보이지 않는 재귀 경우에 약한것 같다.

### 총평
> 백트래킹 경우의 수를 미리 제작해두는 것이 중요한 문제 였던것 같습니다.

### 참고 자료
> 

--- 

## 3주차 2번 문제 BOJ 16571번

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/16571

### 문제 풀이
> [백준/Gold/16571. 알파 틱택토/알파 틱택토.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/8ca7c87b0ff2e7384b1db735e6d7916c81938c50/%EB%B0%B1%EC%A4%80/Gold/16571.%E2%80%85%EC%95%8C%ED%8C%8C%E2%80%85%ED%8B%B1%ED%83%9D%ED%86%A0/%EC%95%8C%ED%8C%8C%E2%80%85%ED%8B%B1%ED%83%9D%ED%86%A0.cc)

### 개념 정리
> **백트래킹 상태복원과 재귀 종료 시점에 따른 출력 정리**

    첫 접근) 좌표 값을 매개변수로 전달해 가로, 세로, 좌하향 대각선, 우하향 대각선을 탐색해 승/패 판단
    이후 재귀 함수 내에서는 단순히 빈 칸만을 탐색하는 방법으로 생각을 하였습니다. 

    두번째 접근) 하지만 틱택토 배열은 3 X 3 배열로 2중 반복문을 사용하더라도 부담이 없었기에 재귀 과정에서 배열 내에 '0' 위치를 찾아서 정답 검사 함수로 전달 이후에 T/F 를 반환해서 정답 / 오답 처리를 하였습니다. 그러나 이러한 방식으로는 false 을 받았을 때 이것이 "무승부 / 패배" 를 구별 할 수없었습니다. 

    세번째 접근) 위의 문제를 해결하기 위해 재귀 과정에서 상대 정답 검사 이후 배열을 탐색해 '0'이 존재하지 않지만 상대방 승리가 아니라면 무승부로 판단하기로 했습니다.
``` C++
    // 틱택토에서 상대 차례, 내 차례를 구별하는 방법
    // * 재귀 함수 & 정답 검사 함수에 매개변수를 Player로 전달
    // * (3 - player) 와 같은 값으로 전달해 매 재귀 마다 1 or 2만 전달

    // 1. 모든 가로줄 검사
	for (int i = 0; i < SIZE; ++i) {
		if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
			return true;
		}
	}
	// 2. 모든 세로줄 검사
	for (int i = 0; i < SIZE; ++i) {
		if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {
			return true;
		}
	}

    # 2개의 반복문을 사용해서 가로/세로를 탐색하였지만
    // 1. 모든 가로줄 검사
	for (int i = 0; i < SIZE; ++i) {
		if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
			return true;
		}
        if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {
			return true;
		}
	}

    # 이와 같이 한개의 반복문으로도 충분히 동작합니다. 다만 가시성을 위해 2개의 반복을 사용하였습니다.
```

> 문제 풀이 과정에서 개선점
    
    승리 / 패배 2가지 결과를 구하는 부분까지는 빠르게 접근하였지만 이후 무승부 / 패배를 판단하는 부분에서 어려움을 겪었습니다. boolean을 사용하는 부분과 2중 반복문을 사용해서 배열 탐색 과정을 한번 더 하여 시간 소모를 하지 않는다 라는 부분에 매몰되어서 쉬운길을 돌아간것 같습니다. 이번 틱택토 같이 배열의 크기가 매우 작게 지정되어 있는 문제의 경우 다중 반복을 활용하는 것도 방법중 하나인것같습니다.

### 총평
> 함수의 반환형을 조절해 결과를 선택하는 방법과 N 중 반복문을 활용하는 것이 하나의 방법이라는 것을 배웠습니다. 

### 참고 자료
> 

---

## 3주차 3번 문제 BOJ 

> 🔗| 문제 Link
> https://www.acmicpc.net/problem/14501

### 문제 풀이
> [백준/Silver/14501. 퇴사/퇴사.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/5ef8042ad8e11fcc1b3e15725ef6b6a0d9d01a8b/%EB%B0%B1%EC%A4%80/Silver/14501.%E2%80%85%ED%87%B4%EC%82%AC/%ED%87%B4%EC%82%AC.cc)

### 개념 정리
> **브루트 포스 재귀 탐색 개념 정리**

    재귀 탐색을 통해서 모든 경우의 수를 탐색한다.
    1. total을 추가하지 않고 다음 날로 넘어가는 경우의 수- 1
    2. total을 추가하고 현재 날짜에 + t 만큼 증가하는 경우의 수 -2

    종료 조건은 현재 날짜가 N 이상인 경우
    But) 최댓값 갱신을 무조건 하는 것이 아닌 현재 날짜 == N 인 경우에만 최댓값 갱신
    
    현재 날짜가 N 초과이면 최댓값 갱신 없이 종료
``` C++
    void slove(int level, int total) {
        // 1. 종료 조건: level이 N 이상
        if (level >= N) {
            // N과 동일한 경우 최댓값 갱신
            if (level == N) {
                maxTotal = max(maxTotal, total);
            }
            // N과 동일하지 않을 경우 초과이므로 갱신 X
            return;
        }

        // 1. 경우의 수 - 다음으로 그냥 넘어가기
        slove(level + 1, total);
        // 2. 경우의 수 - 현재 level + t가 N 이하인 경우 상담 진행 + p 증가
        if (level + matrix[level][0] <= N) {
            slove(level + matrix[level][0], total + matrix[level][1]);
        }
    }

    // 경우의 수 2의 경우 현재 날짜 + t 가 N 이하여야한다.
    // 문제에서 N + 1 일째에 퇴사한다고 했기에 N 미만이 아닌 이하
```

> 문제 풀이 과정에서 개선점
    
    이 문제는 이전에 풀어 보았던 BOJ 1182번 문제와 비슷하여서 알고리즘 설계는 빠르게 할 수 있었던 문제였다. 다만 종료 조건 최댓값 갱신에서 N 이상인 경우에 전부 진행하여 답이 정상적으로 나오지 않는 오류가 있었다. 

### 총평
> 브루트 포스를 이용해 빠르게 접근한 문제였다.

### 참고 자료
> 

