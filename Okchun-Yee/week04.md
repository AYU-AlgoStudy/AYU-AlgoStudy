## 4주차 01번 문제 BOJ 11657

> 🔗| 문제 Link

> https://www.acmicpc.net/problem/11657

### 문제 풀이
> [백준/Gold/11657. 타임머신/타임머신.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/c435d16b7f63adbfd7e3186b360233831e0802ab/%EB%B0%B1%EC%A4%80/Gold/11657.%E2%80%85%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0/%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0.cc)

### 개념 정리
> **최단 거리 탐색: SPFA 알고리즘**
    
    구조적으로는 BFS를 사용하여 최단거리를 찾는 알고리즘이지만, SPFA알고리즘은 음수 가중치가 포함된 그래프에서 최단 거리를 찾는데 특화된 알고리즘입니다.

    BFS와의 차이점
        - in_queue 백터를 사용해 노드가 현재 큐 내부에 있는지 없는지 여부를 검사 (visited 백터와 유사한 역할을 하지만 in_queue는 que에서 노드가 pop 되면 다시 false 처리를 한다.)
        - dist 백터 (거리 백터)가 가중치를 저장하는데 사용된다, 만약 dist가 갱신 (짧은 거리 발견)되면 다시 해당 노드를 push 한다. 
        - '큐에 다시 넣기' 방식이 음수 가중치가 나중에 발견되었을 때에도 최단 거리를 갱신할 수 있게 해준다. 
        - 임의의 노드가 큐에 N + 1회 (정점 수보다 많이) 보다 더 들어간다면 그 노드는 무한루프에 빠진 노드라고 판단. => 음수 사이클
``` C++
    // BFS
    int u = q.front();
	q.pop();				// que 에서 제거
	visited[u] = false;		// 큐에 방문 철회

    // ...

    if (dist[u] + w < dist[v]) {		// 거리가 더 짧은 간선이 존재할 때 실행
        dist[v] = dist[u] + w;			// 최단 거리 업데이트
        if (!visited[v]) {
            q.push(v);
            visited[v] = true;
            count[v]++;
            if (count[v] >= N) {		// 음수 사이클 음수의 수가 >= N
                cout << -1 << "\n";
                return;
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    
기본적인 BFS로 풀려고 시도하다가 굉장히 많이 막혔다. 그래서 해당 문제를 풀 수 있는 알고리즘을 알아보다가 SPFA 알고리즘을 발견하게 되었고 풀 수 있었다. 나는 평소에 DFS와 BFS만 알면 나머지 문제는 응용이라고만 생각했었는데 그게 아니라는 것을 배웠다. 좀 더 다양한 알고리즘들을 알아두고 적시에 활용 할 수 있게 공부가 더 필요한 것 같다.

### 총평
> SPFA 라는 새로운 알고리즘을 알게된 문제였다.

### 참고 자료
> Gemini

---

## 4주차 02번 문제 BOJ 11403번

> 🔗| 문제 Link

> https://www.acmicpc.net/problem/11403 

### 문제 풀이
> [백준/Silver/11403. 경로 찾기/경로 찾기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/312ef50926ebf4d39c45fcd4eea3f62e736dfdc4/%EB%B0%B1%EC%A4%80/Silver/11403.%E2%80%85%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0/%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0.cc)

### 개념 정리
> **플로이드-와샬 (Floyd-Warshall)**
    
    시작점부터 목표점까지 경유지를 통한 거리 갱신, BOJ 11657번 문제에서 사용한 SPFA 알고리즘과 동일하게 최단거리 갱신에 완화 방식(알려진 최단거리와 새로 발견된 최단거리를 비교해 더 짧은 거리로 갱신)을 사용합니다.

    플로이드 와샬 방식은 3중 반복문(DP)을 사용합니다. 
    k = 경유점
    i = 출발점
    j = 도착점
     - i->j 의 경로 (직항)
     - i->k, k->j 의 경로 (경유)가 존재하면 i->j(직항) 경로도 존재한다.

    시간복잡도: O(N^3) (항상 고정)
``` C++
    // 플로드이-와샬 알고리즘 구성
    // 0번부터 (N-1)번까지의 정점을 사용한다고 가정
    // graph는 입력받은 인접 행렬

    // k = 경유지
    for (int k = 0; k < N; ++k) {
        // i = 출발지
        for (int i = 0; i < N; ++i) {
            // j = 도착지
            for (int j = 0; j < N; ++j) {
                
                // "i에서 k로 가는 길이 있고 (직항 또는 경유)"
                // "k에서 j로 가는 길이 있다면"
                if (graph[i][k] == 1 && graph[k][j] == 1) {
                    // "i에서 j로도 갈 수 있다"고 갱신
                    graph[i][j] = 1;
                }
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    플로이드 와샬이라는 새로운 탐색 알고리즘을 알게되었습니다. 월요일 문제 2개를 풀면서 느끼는 점은 "최단거리" 라고 꼭 `queue` 를 사용한 BFS 탐색이 필수가 아니라는 것을 알게되었습니다.

### 총평
> 탐색 기법은 항상 여러 가능성을 열어두자. 

### 참고 자료
> https://ansohxxn.github.io/algorithm/floyd/
