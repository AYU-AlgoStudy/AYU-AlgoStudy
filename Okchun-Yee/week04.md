## 4주차 01번 문제 BOJ 11657

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/11657

### 문제 풀이
> [백준/Gold/11657. 타임머신/타임머신.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/c435d16b7f63adbfd7e3186b360233831e0802ab/%EB%B0%B1%EC%A4%80/Gold/11657.%E2%80%85%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0/%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0.cc)

### 개념 정리
> **최단 거리 탐색: SPFA 알고리즘**
    
    구조적으로는 BFS를 사용하여 최단거리를 찾는 알고리즘이지만, SPFA알고리즘은 음수 가중치가 포함된 그래프에서 최단 거리를 찾는데 특화된 알고리즘입니다.

    BFS와의 차이점
        - in_queue 백터를 사용해 노드가 현재 큐 내부에 있는지 없는지 여부를 검사 (visited 백터와 유사한 역할을 하지만 in_queue는 que에서 노드가 pop 되면 다시 false 처리를 한다.)
        - dist 백터 (거리 백터)가 가중치를 저장하는데 사용된다, 만약 dist가 갱신 (짧은 거리 발견)되면 다시 해당 노드를 push 한다. 
        - '큐에 다시 넣기' 방식이 음수 가중치가 나중에 발견되었을 때에도 최단 거리를 갱신할 수 있게 해준다. 
        - 임의의 노드가 큐에 N + 1회 (정점 수보다 많이) 보다 더 들어간다면 그 노드는 무한루프에 빠진 노드라고 판단. => 음수 사이클
``` C++
    // BFS
    int u = q.front();
	q.pop();				// que 에서 제거
	visited[u] = false;		// 큐에 방문 철회

    // ...

    if (dist[u] + w < dist[v]) {		// 거리가 더 짧은 간선이 존재할 때 실행
        dist[v] = dist[u] + w;			// 최단 거리 업데이트
        if (!visited[v]) {
            q.push(v);
            visited[v] = true;
            count[v]++;
            if (count[v] >= N) {		// 음수 사이클 음수의 수가 >= N
                cout << -1 << "\n";
                return;
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    
기본적인 BFS로 풀려고 시도하다가 굉장히 많이 막혔다. 그래서 해당 문제를 풀 수 있는 알고리즘을 알아보다가 SPFA 알고리즘을 발견하게 되었고 풀 수 있었다. 나는 평소에 DFS와 BFS만 알면 나머지 문제는 응용이라고만 생각했었는데 그게 아니라는 것을 배웠다. 좀 더 다양한 알고리즘들을 알아두고 적시에 활용 할 수 있게 공부가 더 필요한 것 같다.

### 총평
> SPFA 라는 새로운 알고리즘을 알게된 문제였다.

### 참고 자료
> Gemini

---

## 4주차 02번 문제 BOJ 11403번

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/11403 

### 문제 풀이
> [백준/Silver/11403. 경로 찾기/경로 찾기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/312ef50926ebf4d39c45fcd4eea3f62e736dfdc4/%EB%B0%B1%EC%A4%80/Silver/11403.%E2%80%85%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0/%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0.cc)

### 개념 정리
> **플로이드-와샬 (Floyd-Warshall)**
    
    시작점부터 목표점까지 경유지를 통한 거리 갱신, BOJ 11657번 문제에서 사용한 SPFA 알고리즘과 동일하게 최단거리 갱신에 완화 방식(알려진 최단거리와 새로 발견된 최단거리를 비교해 더 짧은 거리로 갱신)을 사용합니다.

    플로이드 와샬 방식은 3중 반복문(DP)을 사용합니다. 
    k = 경유점
    i = 출발점
    j = 도착점
     - i->j 의 경로 (직항)
     - i->k, k->j 의 경로 (경유)가 존재하면 i->j(직항) 경로도 존재한다.

    시간복잡도: O(N^3) (항상 고정)
``` C++
    // 플로드이-와샬 알고리즘 구성
    // 0번부터 (N-1)번까지의 정점을 사용한다고 가정
    // graph는 입력받은 인접 행렬

    // k = 경유지
    for (int k = 0; k < N; ++k) {
        // i = 출발지
        for (int i = 0; i < N; ++i) {
            // j = 도착지
            for (int j = 0; j < N; ++j) {
                
                // "i에서 k로 가는 길이 있고 (직항 또는 경유)"
                // "k에서 j로 가는 길이 있다면"
                if (graph[i][k] == 1 && graph[k][j] == 1) {
                    // "i에서 j로도 갈 수 있다"고 갱신
                    graph[i][j] = 1;
                }
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    플로이드 와샬이라는 새로운 탐색 알고리즘을 알게되었습니다. 월요일 문제 2개를 풀면서 느끼는 점은 "최단거리" 라고 꼭 `queue` 를 사용한 BFS 탐색이 필수가 아니라는 것을 알게되었습니다.

### 총평
> 탐색 기법은 항상 여러 가능성을 열어두자. 

### 참고 자료
> https://ansohxxn.github.io/algorithm/floyd/

---

## 4주차 03번 문제 BOJ 1753번 

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/1753

### 문제 풀이
> [백준/Gold/1753. 최단경로/최단경로.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/0d89c776b13904cd49a1e0acfb15402cc66cf6ae/%EB%B0%B1%EC%A4%80/Gold/1753.%E2%80%85%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C.cc)

### 개념 정리
> **다익스트라 알고리즘**
    
    SPFA와 같은 최단 거리 발견 시 갱신 형식이지만 SPFA가 인접 행렬을 사용했다면, 다익스트라는 인접 리스트를 사용
    인접 행렬의 시간 복잡도 O(V^2)
    인접 리스트의 시간 복잡도 O(V+E) 로 줄일 수 있습니다.
    또한 일반 큐 대신 우선순위 큐를 사용합니다.

    이외의 간선 갱신 조건과 탐색 순서는 SPFA와 동일

    * 우선 순위 큐 사용시에 우선순위를 조절하는 방법으로 먼저, 우선순위 큐는 기본적으로 최대 힙 자료구조를 사용하여 큰 수를 담기 때문에 저장할 때 음수로 치환해서 양수와 순서를 반대로 저장해서 우선순위를 조정한다.
``` C++
    // 가중치가 가장 짧은 노드 (가중치 정렬이 음수기에 다시 양수로)
    long long cur_dist = pq.top().first * -1;

    // 가중치가 작아야 우선순위가 높으니 음수로 저장
    pq.push({ dist[v] * -1, v });	
```

> 문제 풀이 과정에서 개선점
    
    문제를 처음 접했을 때 11657번 타임머신 문제와 비슷하여서 SPFA 알고리즘을 이용해서 문제를 풀었더니 메모리 초과가 발생하였습니다. 이는 인접행렬을 저장할때 min을 사용하면 V^2 탐색이 매번 발생하기때문에 메모리 초과가 발생. 이를 해결하기 위해서 찾아본 알고리즘이 다익스트라였습니다. 앞으로 문제를 풀 때 각 알고리즘의 시간 복잡도를 생각하는 것이 중요하다고 생각이 되는 문제였습니다. 

    SPFA를 다익스트라로 변경하기 위해서 자료구조를 인접행렬 -> 인접리스트로 변경, 큐 -> 우선순위 큐로 변경했습니다.

### 총평
> 비슷한 유형이고, 같은 접근 방식이라 생각했지만 메모리 초과가 발생한 점으로 보아 문제마다 시간복잡도 및 메모리 제한을 잘 파악해야할 것 같다.

### 참고 자료
> 🚫

---

## 4주차 04번 문제 PGS "모음사전"

### 🔗| 문제 Link

> https://school.programmers.co.kr/learn/courses/30/lessons/84512 

### 문제 풀이
> [프로그래머스/2/84512. 모음 사전/모음 사전.cpp](https://github.com/Okchun-Yee/CodingTestStudy/blob/0d89c776b13904cd49a1e0acfb15402cc66cf6ae/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/84512.%E2%80%85%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84/%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84.cpp)

### 개념 정리
> **완전탐색: 중복수열과 자릿값**
    
    5개의 문자와 길이 5개 단어까지 가능하기에 이 자리는 5진법 자릿값을 가집니다.
    각 자리가 바뀔 때마다 건너뛸 수 있는 '자릿수'가 정해져 있는 방법
    - 크기 계산
        1. 문자 한개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 + 5^3 + 5^4 = 781
        2. 문자 두개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 + 5^3 = 156
        3. 문자 세개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 = 31
        4. 문자 네개로 시작하는 단어 수 = 5^0 + 5^1 = 6
        5. 문자 다섯개 = 1

        {781, 156, 31, 6, 1}
    이후 각 문자를 0~4까지 순서대로 매핑하여 자릿수 계산을 시작합니다.

``` C++
    for (int i = 0; i < word.length(); ++i) {
        answer += (alphabet[word[i]] * w[i]);
    }
    // 반복문 종료 후 각 자리의 자기 자신 더하기
    answer += word.length(); 
```

> 문제 풀이 과정에서 개선점
    
    완전 탐색 문제이기에 처음에는 가능한 단어 총 
    5^1 + 5^2 + 5^3 + 5^4 + 5^5 = 5 + 25 + 125 + 625 + 3125 = {3,905}개 전부 배열로 지정하고 
    문자열 비교 연산으로 인덱스를 찾으려 하였지만 해당 방식은 너무 비효율적인 것을 파악했고, 이후 자리값을 이용한 계산방식 찾았습니다. 

    완전 탐색이라고 꼭 전부를 탐색할 필요가 없다는 것을 생각해야 할 것 같습니다.

### 총평
> 완전 탐색이라고 전체 탐색에 매몰되지않는 것이 중요한 문제

### 참고 자료
> 
