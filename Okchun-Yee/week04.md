## 4주차 01번 문제 BOJ 11657

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/11657

### 문제 풀이
> [백준/Gold/11657. 타임머신/타임머신.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/c435d16b7f63adbfd7e3186b360233831e0802ab/%EB%B0%B1%EC%A4%80/Gold/11657.%E2%80%85%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0/%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0.cc)

### 개념 정리
> **최단 거리 탐색: SPFA 알고리즘**
    
    구조적으로는 BFS를 사용하여 최단거리를 찾는 알고리즘이지만, SPFA알고리즘은 음수 가중치가 포함된 그래프에서 최단 거리를 찾는데 특화된 알고리즘입니다.

    BFS와의 차이점
        - in_queue 백터를 사용해 노드가 현재 큐 내부에 있는지 없는지 여부를 검사 (visited 백터와 유사한 역할을 하지만 in_queue는 que에서 노드가 pop 되면 다시 false 처리를 한다.)
        - dist 백터 (거리 백터)가 가중치를 저장하는데 사용된다, 만약 dist가 갱신 (짧은 거리 발견)되면 다시 해당 노드를 push 한다. 
        - '큐에 다시 넣기' 방식이 음수 가중치가 나중에 발견되었을 때에도 최단 거리를 갱신할 수 있게 해준다. 
        - 임의의 노드가 큐에 N + 1회 (정점 수보다 많이) 보다 더 들어간다면 그 노드는 무한루프에 빠진 노드라고 판단. => 음수 사이클
``` C++
    // BFS
    int u = q.front();
	q.pop();				// que 에서 제거
	visited[u] = false;		// 큐에 방문 철회

    // ...

    if (dist[u] + w < dist[v]) {		// 거리가 더 짧은 간선이 존재할 때 실행
        dist[v] = dist[u] + w;			// 최단 거리 업데이트
        if (!visited[v]) {
            q.push(v);
            visited[v] = true;
            count[v]++;
            if (count[v] >= N) {		// 음수 사이클 음수의 수가 >= N
                cout << -1 << "\n";
                return;
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    
기본적인 BFS로 풀려고 시도하다가 굉장히 많이 막혔다. 그래서 해당 문제를 풀 수 있는 알고리즘을 알아보다가 SPFA 알고리즘을 발견하게 되었고 풀 수 있었다. 나는 평소에 DFS와 BFS만 알면 나머지 문제는 응용이라고만 생각했었는데 그게 아니라는 것을 배웠다. 좀 더 다양한 알고리즘들을 알아두고 적시에 활용 할 수 있게 공부가 더 필요한 것 같다.

### 총평
> SPFA 라는 새로운 알고리즘을 알게된 문제였다.

### 참고 자료
> Gemini

---

## 4주차 02번 문제 BOJ 11403번

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/11403 

### 문제 풀이
> [백준/Silver/11403. 경로 찾기/경로 찾기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/312ef50926ebf4d39c45fcd4eea3f62e736dfdc4/%EB%B0%B1%EC%A4%80/Silver/11403.%E2%80%85%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0/%EA%B2%BD%EB%A1%9C%E2%80%85%EC%B0%BE%EA%B8%B0.cc)

### 개념 정리
> **플로이드-와샬 (Floyd-Warshall)**
    
    시작점부터 목표점까지 경유지를 통한 거리 갱신, BOJ 11657번 문제에서 사용한 SPFA 알고리즘과 동일하게 최단거리 갱신에 완화 방식(알려진 최단거리와 새로 발견된 최단거리를 비교해 더 짧은 거리로 갱신)을 사용합니다.

    플로이드 와샬 방식은 3중 반복문(DP)을 사용합니다. 
    k = 경유점
    i = 출발점
    j = 도착점
     - i->j 의 경로 (직항)
     - i->k, k->j 의 경로 (경유)가 존재하면 i->j(직항) 경로도 존재한다.

    시간복잡도: O(N^3) (항상 고정)
``` C++
    // 플로드이-와샬 알고리즘 구성
    // 0번부터 (N-1)번까지의 정점을 사용한다고 가정
    // graph는 입력받은 인접 행렬

    // k = 경유지
    for (int k = 0; k < N; ++k) {
        // i = 출발지
        for (int i = 0; i < N; ++i) {
            // j = 도착지
            for (int j = 0; j < N; ++j) {
                
                // "i에서 k로 가는 길이 있고 (직항 또는 경유)"
                // "k에서 j로 가는 길이 있다면"
                if (graph[i][k] == 1 && graph[k][j] == 1) {
                    // "i에서 j로도 갈 수 있다"고 갱신
                    graph[i][j] = 1;
                }
            }
        }
    }
```

> 문제 풀이 과정에서 개선점
    플로이드 와샬이라는 새로운 탐색 알고리즘을 알게되었습니다. 월요일 문제 2개를 풀면서 느끼는 점은 "최단거리" 라고 꼭 `queue` 를 사용한 BFS 탐색이 필수가 아니라는 것을 알게되었습니다.

### 총평
> 탐색 기법은 항상 여러 가능성을 열어두자. 

### 참고 자료
> https://ansohxxn.github.io/algorithm/floyd/

---

## 4주차 03번 문제 BOJ 1753번 

### 🔗| 문제 Link

> https://www.acmicpc.net/problem/1753

### 문제 풀이
> [백준/Gold/1753. 최단경로/최단경로.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/0d89c776b13904cd49a1e0acfb15402cc66cf6ae/%EB%B0%B1%EC%A4%80/Gold/1753.%E2%80%85%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C.cc)

### 개념 정리
> **다익스트라 알고리즘**
    
    SPFA와 같은 최단 거리 발견 시 갱신 형식이지만 SPFA가 인접 행렬을 사용했다면, 다익스트라는 인접 리스트를 사용
    인접 행렬의 시간 복잡도 O(V^2)
    인접 리스트의 시간 복잡도 O(V+E) 로 줄일 수 있습니다.
    또한 일반 큐 대신 우선순위 큐를 사용합니다.

    이외의 간선 갱신 조건과 탐색 순서는 SPFA와 동일

    * 우선 순위 큐 사용시에 우선순위를 조절하는 방법으로 먼저, 우선순위 큐는 기본적으로 최대 힙 자료구조를 사용하여 큰 수를 담기 때문에 저장할 때 음수로 치환해서 양수와 순서를 반대로 저장해서 우선순위를 조정한다.
``` C++
    // 가중치가 가장 짧은 노드 (가중치 정렬이 음수기에 다시 양수로)
    long long cur_dist = pq.top().first * -1;

    // 가중치가 작아야 우선순위가 높으니 음수로 저장
    pq.push({ dist[v] * -1, v });	
```

> 문제 풀이 과정에서 개선점
    
    문제를 처음 접했을 때 11657번 타임머신 문제와 비슷하여서 SPFA 알고리즘을 이용해서 문제를 풀었더니 메모리 초과가 발생하였습니다. 이는 인접행렬을 저장할때 min을 사용하면 V^2 탐색이 매번 발생하기때문에 메모리 초과가 발생. 이를 해결하기 위해서 찾아본 알고리즘이 다익스트라였습니다. 앞으로 문제를 풀 때 각 알고리즘의 시간 복잡도를 생각하는 것이 중요하다고 생각이 되는 문제였습니다. 

    SPFA를 다익스트라로 변경하기 위해서 자료구조를 인접행렬 -> 인접리스트로 변경, 큐 -> 우선순위 큐로 변경했습니다.

### 총평
> 비슷한 유형이고, 같은 접근 방식이라 생각했지만 메모리 초과가 발생한 점으로 보아 문제마다 시간복잡도 및 메모리 제한을 잘 파악해야할 것 같다.

### 참고 자료
> 🚫

---

## 4주차 04번 문제 PGS "모음사전"

### 🔗| 문제 Link

> https://school.programmers.co.kr/learn/courses/30/lessons/84512 

### 문제 풀이
> [프로그래머스/2/84512. 모음 사전/모음 사전.cpp](https://github.com/Okchun-Yee/CodingTestStudy/blob/0d89c776b13904cd49a1e0acfb15402cc66cf6ae/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/84512.%E2%80%85%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84/%EB%AA%A8%EC%9D%8C%E2%80%85%EC%82%AC%EC%A0%84.cpp)

### 개념 정리
> **완전탐색: 중복수열과 자릿값**
    
    5개의 문자와 길이 5개 단어까지 가능하기에 이 자리는 5진법 자릿값을 가집니다.
    각 자리가 바뀔 때마다 건너뛸 수 있는 '자릿수'가 정해져 있는 방법
    - 크기 계산
        1. 문자 한개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 + 5^3 + 5^4 = 781
        2. 문자 두개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 + 5^3 = 156
        3. 문자 세개로 시작하는 단어 수 = 5^0 + 5^1 + 5^2 = 31
        4. 문자 네개로 시작하는 단어 수 = 5^0 + 5^1 = 6
        5. 문자 다섯개 = 1

        {781, 156, 31, 6, 1}
    이후 각 문자를 0~4까지 순서대로 매핑하여 자릿수 계산을 시작합니다.

``` C++
    for (int i = 0; i < word.length(); ++i) {
        answer += (alphabet[word[i]] * w[i]);
    }
    // 반복문 종료 후 각 자리의 자기 자신 더하기
    answer += word.length(); 
```

> 문제 풀이 과정에서 개선점
    
    완전 탐색 문제이기에 처음에는 가능한 단어 총 
    5^1 + 5^2 + 5^3 + 5^4 + 5^5 = 5 + 25 + 125 + 625 + 3125 = {3,905}개 전부 배열로 지정하고 
    문자열 비교 연산으로 인덱스를 찾으려 하였지만 해당 방식은 너무 비효율적인 것을 파악했고, 이후 자리값을 이용한 계산방식 찾았습니다. 

    완전 탐색이라고 꼭 전부를 탐색할 필요가 없다는 것을 생각해야 할 것 같습니다.

### 총평
> 완전 탐색이라고 전체 탐색에 매몰되지않는 것이 중요한 문제

### 참고 자료
> 

---

## 4주차 05번 문제 BOJ 17073번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/17073

### 문제 풀이
> [백준/Gold/17073. 나무 위의 빗물/나무 위의 빗물.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/55a91c953a3f6d4a3238a60565452e3263c6c89a/%EB%B0%B1%EC%A4%80/Gold/17073.%E2%80%85%EB%82%98%EB%AC%B4%E2%80%85%EC%9C%84%EC%9D%98%E2%80%85%EB%B9%97%EB%AC%BC/%EB%82%98%EB%AC%B4%E2%80%85%EC%9C%84%EC%9D%98%E2%80%85%EB%B9%97%EB%AC%BC.cc)

### 개념 정리
> **터미널 노드 탐색**

    문제를 처음 보았을 때 생각했던 것은 각 터미널 노드에 확률은 동일하지않나? 였습니다. 그렇기에 접근 방식을 바로 물의 총량 / 터미널 노드의 수 로 접근 하였습니다. 

    그 이후 터미널 노드를 파악하는 방식에 대해서 고민하였는데 가장 쉬운 접근 방법으로 각 간선의 인접 리스트를 생성하고 연결된 간선이 1개이면 터미널 노드로 판단하는 방식이였습니다.

> 문제 풀이 과정에서 개선점

    😙
### 총평
> 인접 리스트 활용, 트리에 대한 이해가 있으면 어렵지 않은 문제였던 것 같습니다.

### 참고 자료
> 

---

## 4주차 06번 문제 PGS "가장 큰 수"

### 🔗| 문제 Link

> https://school.programmers.co.kr/learn/courses/30/lessons/42746

### 문제 풀이
> [프로그래머스/2/42746. 가장 큰 수/가장 큰 수.cpp](https://github.com/Okchun-Yee/CodingTestStudy/blob/98365235903a6eac200fc61e3cd9250fa4fd5e5b/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42746.%E2%80%85%EA%B0%80%EC%9E%A5%E2%80%85%ED%81%B0%E2%80%85%EC%88%98/%EA%B0%80%EC%9E%A5%E2%80%85%ED%81%B0%E2%80%85%EC%88%98.cpp)

### 개념 정리
> **정렬 알고리즘이란?**

    해당 문제는 총 2번의 실패를 하였습니다. 
    첫 실패로는 먼저 문제를 봤을 때 백트래킹으로 모든 원소를 쓰는 숫자를 만들면서 최댓값 갱신을 하는 방식으로 접근했지만 시간 초과가 발생하였습니다.
    ⌛시간 복잡도: O(N!):N -> N 이 12만 이상이면 시간 초과

    백 트래킹 탐색으로는 시간 초과라 생각해서 "i"+"(i+1)" 과 "(i+1)"+"i" 를 비교하여서 버블 정렬을 n^2 번 진행하는 방식의 버블정렬을 사용해 풀었지만 시간 초과가 발생하였습니다. 
    ⌛시간 복잡도: O(N^2) -> 시간 초과

    최종적으로 빠른 정렬 알고리즘인 sort 정렬을 사용하였습니다. 
    버블 정렬에서 사용한 알고리즘을 compare 커스텀 비교 함수로 만들어서 사용해 정답을 발견하였습니다.
    ⌛시간 복잡도: O(N log N)

``` C++
    bool compare(int a, int b) {
        string s1 = to_string(a) + to_string(b);
        string s2 = to_string(b) + to_string(a);

        // s1 > s2 이면 a가 b 앞으로 와야함
        return s1 > s2;
    }
```

> 문제 풀이 과정에서 개선점
    
    아직 각 알고리즘 마다의 시간 복잡도를 정확하게 알지는 못하는 것 같다. 조건을 보았을 때 N의 수에 따라서 가능한 시간 복잡도를 가진 알고리즘을 찾는 능력을 더 길러야 할 것 같다.

### 총평
> 문제에 필요한 시간 복잡도를 가진 알고리즘을 찾는데 어려움을 겪었던 문제였다. sort 매서드를 활용한 정렬이 시간이 매우 빠르다는 것을 알게되었다.

### 참고 자료
> 

---

## 4주차 07번 문제 BOJ 1463번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/1463

### 문제 풀이
> [백준/Silver/1463. 1로 만들기/1로 만들기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/e8e86422fd9cc13a455fa627fce6891f75c1bff7/%EB%B0%B1%EC%A4%80/Silver/1463.%E2%80%851%EB%A1%9C%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0/1%EB%A1%9C%E2%80%85%EB%A7%8C%EB%93%A4%EA%B8%B0.cc)

### 개념 정리
> **DP 개념 정리**
    
    해당 문제는 1번의 시간 초과가 있었습니다. 첫 접근 방식은 브루트 포스였습니다. 
    +1인경우, /2인 경우, /3인 경우를 전부 DFS 재귀로 탐색을 하는 방식을 사용했습니다. 그러나 이 방식은 N이 커지는 경우 시간 복잡도가 기하급수적으로 늘어났기에 다른 방식이 필요햇습니다.

    이때 DP를 사용하는 것입니다. 다이나믹 프로그래밍은 "이전 결과 저장 -> 중복 호출 시 재사용" 이라는 방식으로 연산을 최대한으로 줄일 수 있습니다. 그렇기에 DFS 재귀와 다르게 굉장히 적은 반복만을 사용할 수 있습니다. 

    dp[i] = "i를 1로 만드는 데 필요한 최소 연산 횟수

    <점화식>
    1. dp[i]는 일단 dp[i-1] + 1 (1 빼기)의 횟수를 가집니다.
    2.i가 2로 나눠지면, dp[i/2] + 1 (2 나누기)과 1번의 횟수를 비교해 더 작은 값을 dp[i]에 저장합니다.
    3. i가 3으로 나눠지면, dp[i/3] + 1 (3 나누기)과 현재 dp[i] 값을 비교해 더 작은 값을 저장합니다.

    ⌛시간 복잡도: O(N)
``` C++
    for (int i = 2; i <= n; ++i) {
		dp[i] = dp[i - 1] + 1;
		if (i % 2 == 0)
			dp[i] = min(dp[i], dp[i / 2] + 1);
		if (i % 3 == 0)
			dp[i] = min(dp[i], dp[i / 3] + 1);
	}
```

> 문제 풀이 과정에서 개선점
    
    다이나믹 프로그래밍은 어떤 특정 알고리즘이라기 보다는 접근 방식을 통칭하는 말이기 때문에
    어떤 알고리즘으로 접근해야하는지에 대한 고민이 많은 것 같다. 
    DP의 가장 핵심 아이디어는 "중복되는 하위 문제의 답을 재사용" 인 것같다.

### 총평
> 그동안 고정된 알고리즘만 자주 풀었는데 알고리즘이 정해지지 않고, 접근 방식부터 생각하는 것이 조금 어려운 것 같다.

### 참고 자료
> 

---

## 4주차 08번 문제 PGS "체육복"

### 🔗| 문제 Link
> https://school.programmers.co.kr/learn/courses/30/lessons/42862

### 문제 풀이
> [프로그래머스/1/42862. 체육복/체육복.cpp](https://github.com/Okchun-Yee/CodingTestStudy/blob/77a7555606e0601ed1bcf006039a88ddbfcd006e/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/1/42862.%E2%80%85%EC%B2%B4%EC%9C%A1%EB%B3%B5/%EC%B2%B4%EC%9C%A1%EB%B3%B5.cpp)

### 개념 정리
> **중복 제거 및 방문 처리**
    
    여벌 체육복을 가진 사람 <-> 없는 사람이 중복으로 존재할 수 있기에 
    여벌 체육복을 가진 사람 배열 과 체육복이 없는 사람 배열을 각각 생성 -> 빌려주거나 빌리는 이벤트가 발생 시 해당 배열에 방문 처리를 하여 중복으로 빌리거나 or 빌려주는 상황을 방지


> 문제 풀이 과정에서 개선점
    
    여벌 체육복을 가진 사람과 체육복이 없는 사람이 중복으로 존재 할 수 있다는 점을 파악하지 못해서 문제 파악에 시간이 조금 필요했습니다.

### 총평
> 중복 배열을 2개를 사용했는데 이 점이 조금 더 최적화가 가능 할 것이라고 생각이됩니다.

### 참고 자료
> 

---

## 4주차 09번 문제 BOJ 18870번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/18870

### 문제 풀이
> [백준/Silver/18870. 좌표 압축/좌표 압축.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/48345bcb43710b1b1693ede8badce3c8b71be4ab/%EB%B0%B1%EC%A4%80/Silver/18870.%E2%80%85%EC%A2%8C%ED%91%9C%E2%80%85%EC%95%95%EC%B6%95/%EC%A2%8C%ED%91%9C%E2%80%85%EC%95%95%EC%B6%95.cc)

### 개념 정리
> **중복제거 및 지정자**
     
    직선 그래프를 값 순서대로 정렬을 하고 중복을 제거합니다.
    이후 딕셔너리에 정점 : 인덱스로 매핑을 진행  -> 오름차순으로 정렬을 하였기에 인덱스의 순서가 곧 자신보다 작은 정점의 수
``` C++
    // 값 순서대로 정렬 -> 중복 뒤로 이동 -> 중복 부분 제거 = 중복 없는 임시 배열 완성
	sort(temp.begin(), temp.end());
	auto it = unique(temp.begin(), temp.end());
	temp.erase(it, temp.end());

```

> 문제 풀이 과정에서 개선점
    

### 총평
> 지정자를 사용한 중복 제거를 알게되었다. 

### 참고 자료
> 

---

## 4주차 10번 문제 BOJ 2615번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/2615

### 문제 풀이
> [백준/Silver/2615. 오목/오목.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/ab108846addcb66d64c6eacd98e4c339d7fb9f83/%EB%B0%B1%EC%A4%80/Silver/2615.%E2%80%85%EC%98%A4%EB%AA%A9/%EC%98%A4%EB%AA%A9.cc)

### 개념 정리
> **브루트 포스 & 구현**

    19 * 19 크기의 배열을 탐색하는 문제입니다. 이 때 탐색 범위 지정을 main에서 좌표값 지정해서 slove 함수로 보낸 후 해당 좌표의 가로/세로/대각선을 탐색해서 승/패 판단.

    #define SIZE 19
    가로줄 범위: (x-x) ~ SIZE
    세로줄 범위: (y-y) ~ SIZE
    오른쪽 대각선 범위: (0, 0) ~ (SIZE, SIZE)
    왼쪽 대각선 범위: (0, SIZE) ~ (SIZE, 0)
``` C++
    
```

> 문제 풀이 과정에서 개선점
    
    첫 탐색에서는 (x, y) 앞 뒤로 +/- 4 칸 씩 탐색 했지만 이 방식으로는 6목인 경우 패배 처리가 불가능 해서 줄 전체 탐색으로 변경.

    이 때 무승부 처리를 하지 않아서 오답이 발생하였고, slove 함수가 끝에 도달 시 승리 처리가 되지 않아서 무승부로 판단.

### 총평
> n퀸 & 알파 틱택토와 비슷했던 문제였던것 같다. 

### 참고 자료
> 

---

## 4주차 11번 문제 BOJ 11000번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/11000

### 문제 풀이
> [백준/Gold/11000. 강의실 배정/강의실 배정.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/a84812c076b0c300d2fec665018a775f3d5892a9/%EB%B0%B1%EC%A4%80/Gold/11000.%E2%80%85%EA%B0%95%EC%9D%98%EC%8B%A4%E2%80%85%EB%B0%B0%EC%A0%95/%EA%B0%95%EC%9D%98%EC%8B%A4%E2%80%85%EB%B0%B0%EC%A0%95.cc)

### 개념 정리
> **그리디 알고리즘 & 우선 순위 큐**

    해당 문제는 접근 방식에서 여러번 실패를 하였던 문제였습니다.

    먼저 t_i <= s_j 만 보고 이 문제를 인접 리스트로 해결하러 했습니다. 시작-끝 노드를 생성하고 노드를 타고 가면서 이어지는 강의인지 아닌지를 판단하는 방식을 하려했으나 이방식으로는 t_i 와 s_j가 같은 경우는 해결이 가능하지만 초과인 경우를 탐색하지 못하는 문제가 존재했습니다.

    이 때 우선순위 큐를 사용해서 각 강의의 시작 시간을 기준으로 판단을 하는 방식을 사용했습니다.
    먼저 강의 시간 구조체를 생성하고 해당 배열을 시작 시간 오름차순으로 정렬 이때 greater<int>를 사용하면 오름차순으로 우선순위를 가져가면서 작은 값이 큰 우선순위를 가지게 됩니다. 이후 compare 정렬을 사용하면서 
    1) 시작 시간 오름차순으로 정렬 
    2) 시작 시간이 동일 한 경우 종료 시간 오름차순으로 정렬

    이후 우선순위 큐에 삽입.
    1) 다음 강의 시작 시간 >= 현재 강의 종료 시간 -> 같은 교실 사용 pop() 후 push()
    2) 아닌 경우 -> 다른 교실 사용 push()만 진행

> 문제 풀이 과정에서 개선점
    계속 인접 리스트로 접근 하려는 경향을 보이는 것같다. 큐 및 우선순위 큐 같은 알고리즘의 특성을 잘 파악해서 적재적소에 사용하는 능력을 길러야하는 것 같다. 

### 총평
> 우선 순위 큐에서 우선 순위를 설정하는 방법과 정렬을 동시에 활용하는 문제. 저번 1753번 문제에서 우선 순위 큐를 사용할 때에는 우선순위를 조절하기 위해서 값을 음수로 만들고 저장하고 사용할떄 다시 양수로 변환 했었는데 이럴 필요가 없는 옵션이 존재하는 것을 알게 되었다.

### 참고 자료
> 


