## 5주차 01번 문제 BOJ 11779번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/11779

### 문제 풀이
> [백준/Gold/11779. 최소비용 구하기 2/최소비용 구하기 2.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/9d69563de1601f7ef1bd6f88bca994c5fb294bd6/%EB%B0%B1%EC%A4%80/Gold/11779.%E2%80%85%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0%E2%80%852/%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0%E2%80%852.cc)

### 개념 정리
> **다익스트라 : 인접리스트와 우선순위 큐**

    문제를 처음 접했을 때에는 1753번 문제와 동일한 문제라고 생각했습니다. 그렇기에 바로 최단거리 알고리즘, 우선순위 큐를 사용한 다익스트라 알고리즘을 생각했고, 그렇게 최단거리를 구하는 방법까지는 쉽게 도달을 하였으나 내가 탐색한 경로가 어떤 노드를 거쳐왔는지를 생각해 내는데 시간이 소요되었습니다. 이때 생각 난 것이 13913번 문제에서 사용한 역추적 알고리즘이 생각나서 경로가 갱신 될 때 마다 해당 노드의 부모 노드를 저장하고 역추적 하여 지나온 경로를 알 수 있게 되었습니다.
``` C++
    vector<int> dist(n + 1, INT_INF);	// 최단 거리 배열
    vector<int> parent(n + 1, -1);		// 역추적 배열
    vector<int> answer;					// 정답 배열

    priority_queue<pair<int, int>,      // {비용, 사람 수}
    vector<pair<int, int>>,             // 우선순위 큐를 저장 할 위치
    greater<pair<int, int>>> pq;		// 우선순위 큐의 우선순위
    // * greater은 오름차순 우선순위: 작은 값이 높은 우선순위
    // * less는 내림차순 우선순위: 큰 값이 높은 우선순위

    // 다익스트라 의사코드
    int n, m;
    int START, END;
    vector<vector<pair<int, int>>> graph;	// 인접 리스트

    // dijkstra 알고리즘
    void dijkstra(startNode):
        // 1. 초기화
        dist 배열의 모든 값을 INF로 초기화
        parent 배열을 -1로 초기화 : -1 초기화 = 시작 위치 포함, 0 초기화 = 미포함
        // 2. 시작 노드 설정
        pq.push({비용 0, 시작노드})
        dist[시작노드] = 0 으로 초기화
        // 3. dijkstra 알고리즘 시작 !pq.empty() 동안 반복
        시작점-현재노드까지의 비용 = 큐에서 비용이 가장 적은 노드: pq.top().first;
        현재노드 = pq.top().second;
        pq.pop();
        [최적화] 큐에서 꺼낸 비용이 기존의 최단거리보다 크다면 = continue;
        현재노드와 연결된 모든 이웃노드 확인
            이웃노드 = 현재노드.top().first;
            시작점-이웃노드까지의 비용 = 현재노드.top().second;
            // 5. 최단 거리 갱신
            새로운 경로가 기존 경로보다 짧은 경우: dist[u]+w < dist[v]
            최단거리 갱신
            부모노드 저장: 경로 추적
            갱신된 정보를 큐에 저장 pq.push({새경로, 이웃노드})
        // 6. 경로 역추적
        END 부터 역추적 -1이 나올때까지 (시작점)
```

> 문제 풀이 과정에서 개선점
    
    다익스트라 알고리즘이라고 떠올린 것까지는 빨랐지만 그 이후과정이 매우 느렸다. 특히 지금 경로를 기록하는 과정을 쉽게 떠올리지 못했고, 블로그의 도움을 받았다.

### 총평
> 지금껏 한번에 한개의 알고리즘 위주로만 사용해왔었는데, 2개 이상의 알고리즘도 같이 사용하는 상황이 많아질 것이라는 것을 배웠다.

### 참고 자료
> 
