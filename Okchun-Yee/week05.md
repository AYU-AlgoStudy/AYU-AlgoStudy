## 5주차 01번 문제 BOJ 11779번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/11779

### 문제 풀이
> [백준/Gold/11779. 최소비용 구하기 2/최소비용 구하기 2.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/9d69563de1601f7ef1bd6f88bca994c5fb294bd6/%EB%B0%B1%EC%A4%80/Gold/11779.%E2%80%85%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0%E2%80%852/%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0%E2%80%852.cc)

### 개념 정리
> **다익스트라 : 인접리스트와 우선순위 큐**

    문제를 처음 접했을 때에는 1753번 문제와 동일한 문제라고 생각했습니다. 그렇기에 바로 최단거리 알고리즘, 우선순위 큐를 사용한 다익스트라 알고리즘을 생각했고, 그렇게 최단거리를 구하는 방법까지는 쉽게 도달을 하였으나 내가 탐색한 경로가 어떤 노드를 거쳐왔는지를 생각해 내는데 시간이 소요되었습니다. 이때 생각 난 것이 13913번 문제에서 사용한 역추적 알고리즘이 생각나서 경로가 갱신 될 때 마다 해당 노드의 부모 노드를 저장하고 역추적 하여 지나온 경로를 알 수 있게 되었습니다.
``` C++
    vector<int> dist(n + 1, INT_INF);	// 최단 거리 배열
    vector<int> parent(n + 1, -1);		// 역추적 배열
    vector<int> answer;					// 정답 배열

    priority_queue<pair<int, int>,      // {비용, 사람 수}
    vector<pair<int, int>>,             // 우선순위 큐를 저장 할 위치
    greater<pair<int, int>>> pq;		// 우선순위 큐의 우선순위
    // * greater은 오름차순 우선순위: 작은 값이 높은 우선순위
    // * less는 내림차순 우선순위: 큰 값이 높은 우선순위

    // 다익스트라 의사코드
    int n, m;
    int START, END;
    vector<vector<pair<int, int>>> graph;	// 인접 리스트

    // dijkstra 알고리즘
    void dijkstra(startNode):
        // 1. 초기화
        dist 배열의 모든 값을 INF로 초기화
        parent 배열을 -1로 초기화 : -1 초기화 = 시작 위치 포함, 0 초기화 = 미포함
        // 2. 시작 노드 설정
        pq.push({비용 0, 시작노드})
        dist[시작노드] = 0 으로 초기화
        // 3. dijkstra 알고리즘 시작 !pq.empty() 동안 반복
        시작점-현재노드까지의 비용 = 큐에서 비용이 가장 적은 노드: pq.top().first;
        현재노드 = pq.top().second;
        pq.pop();
        [최적화] 큐에서 꺼낸 비용이 기존의 최단거리보다 크다면 = continue;
        현재노드와 연결된 모든 이웃노드 확인
            이웃노드 = 현재노드.top().first;
            시작점-이웃노드까지의 비용 = 현재노드.top().second;
            // 5. 최단 거리 갱신
            새로운 경로가 기존 경로보다 짧은 경우: dist[u]+w < dist[v]
            최단거리 갱신
            부모노드 저장: 경로 추적
            갱신된 정보를 큐에 저장 pq.push({새경로, 이웃노드})
        // 6. 경로 역추적
        END 부터 역추적 -1이 나올때까지 (시작점)
```

> 문제 풀이 과정에서 개선점
    
    다익스트라 알고리즘이라고 떠올린 것까지는 빨랐지만 그 이후과정이 매우 느렸다. 특히 지금 경로를 기록하는 과정을 쉽게 떠올리지 못했고, 블로그의 도움을 받았다.

### 총평
> 지금껏 한번에 한개의 알고리즘 위주로만 사용해왔었는데, 2개 이상의 알고리즘도 같이 사용하는 상황이 많아질 것이라는 것을 배웠다.

### 참고 자료
> 

---

## 5주차 02번 문제 BOJ 1106번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/1106

### 문제 풀이
> [백준/Gold/1106. 호텔/호텔.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/8751ba550fd5b3c42967ba322796eaa72b19b515/%EB%B0%B1%EC%A4%80/Gold/1106.%E2%80%85%ED%98%B8%ED%85%94/%ED%98%B8%ED%85%94.cc)

### 개념 정리
> **DP**

    모든 DP 문제의 핵심은 큰 문제를 작은 문제로 쪼개고, 그 작은 문제의 답을 저장해 두고 재사용하는 것입니다. 그렇기에 DP 문제를 보고 큰 문제와 쪼갤 작은 문제를 빠르게 파악하는 것이 중요하다고 생각합니다.

    1106번 문제는 최소비용으로 C이상을 달성하는 문제입니다.
    dp[i] 를 정확히 i 명의 고객을 모드는 데 드는 최소 비용으로 생각합니다.
    dp[0]은 0입니다. 0명을 모으는데는 비용이 들지 않습니다.

    dp 배열의 크기는 C + 101 입니다. 입력의 최댓값이 100이기 때문입니다.
    점화식을 세워 보면 

    dp[i]=min(dp[i], dp[i-사람 수] + 비용) 이라는 식이 나오게 됩니다.

    이때 큰 문제: dp[i] = i 명의 고객을 모으는 최소비용
    작은 문제 : dp[i-v] = dp[0]부터 dp[i-1]까지 이미 계산된 값들
``` C++
    // 의사 코드
    int C, N;
    vector<pair<int, int>> citys;

    void  DP():
        // 1. DP table 초기화
        dp[] 배열의 크기는 (C+1 ~ C +101) 의 크기를 가집니다. = 최대 고객 수: 100
        모든 dp[] 값을 INF로 설정
        // 2. BaseCase 설정
        dp[0] = 0명의 고객을 모으는 비용은 0원입니다.
        // 3. DP 테이블 채우기
        for(int i=1;i<C+101;++i):
            i는 현재 목표하는 고객 수 입니다. 1 ~ C+101까지
            for(int j=0;j<N;++j):
                모든 도시를 순회하며 i명이 가능한지 검사합니다.
                w = [j].비용
                v = [j].사람 수
                #if v가 i보다 작고 && dp[i-v]!=INF (이전 위치가 존재)
                [점화식]: dp[i]=min(dp[i], dp[i-v] + w)
        // 4. 최종 정답 찾기
        for(int i=C;i<C+101;++i):
            dp[C]...dp[C+101] 까지 중에서 가장 작은 비용 찾기
```

> 문제 풀이 과정에서 개선점
    
    다른 문제와 달리 DP 문제는 바로 머리속에 접근 방법이 떠오르지 않는다. 이번 문제도 결국 풀지 못하고 외부 도움을 받았다. DP에서 큰문제/작은 문제를 나누는 기준을 잡기가 너무 어려운 것같다. 좀 더 많은 유형의 DP를 풀어봐야 할 것 같다.

### 총평
>  DP 문제를 더 많이 풀어봐야 할 것 같다.

### 참고 자료
> 

---

## 5주차 03번 문제 BOJ 9095번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/9095

### 문제 풀이
> [백준/Silver/9095. 1， 2， 3 더하기/1， 2， 3 더하기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/dd0474bb57fc5d92a20beb36e7c7d5f31499636a/%EB%B0%B1%EC%A4%80/Silver/9095.%E2%80%851%EF%BC%8C%E2%80%852%EF%BC%8C%E2%80%853%E2%80%85%EB%8D%94%ED%95%98%EA%B8%B0/1%EF%BC%8C%E2%80%852%EF%BC%8C%E2%80%853%E2%80%85%EB%8D%94%ED%95%98%EA%B8%B0.cc)

### 개념 정리
> **DP와 점화식 세우기**

    n을 만드는 3가지 방법
    dp[n]은 n을 만드는 모든 경우의 수를 더한 값

    1. (n-1)을 만드는 모든 방법에 +1을 더한다. (경우의 수: dp[n-1])
    2. (n-2)를 만드는 모든 방법에 +2를 더한다. (경우의 수: dp[n-2])
    3. (n-3)을 만드는 모든 방법에 +3을 더한다. (경우의 수: dp[n-3])

    즉) dp[n] = dp[n-1]+dp[n-2]+dp[n-3]


> 문제 풀이 과정에서 개선점
    
    문제의 점화식에는 빠르게 접근했지만 2가지 실수를 하였다. 
    두가지 실수는 이어지는 실수 였는데 실수의 원인으로는 BaseCase 설정을 잘못하였다. dp[1] = 1 이라고 생각하여서 진행을 하니 값이 기존의 연산을 더하는 값오는 문제가 있었다. 
    이유는 dp[n]=dp[n-1]+1 과 같이 본인 연산 횟수를 같이 더해서 계속 연산 수가 고정되어 나오는 것이였다. basecase를 dp[0] = 1로 수정하고, 본인 연산 더하기를 지워서 문제를 해결했다.

### 총평
> dp 점화식을 세워볼 수 있는 간단한 문제였다. basecase 설정이 틀렸지만 점화식 접근을 올바르게 했다는 점에서 발전한 것 같다.

### 참고 자료
> 

---

## 5주차 04번 문제 BOJ 2579 

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/2579

### 문제 풀이
> [백준/Silver/2579. 계단 오르기/계단 오르기.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/98356fce4449d5b7597f55c585178cfb169b5ff7/%EB%B0%B1%EC%A4%80/Silver/2579.%E2%80%85%EA%B3%84%EB%8B%A8%E2%80%85%EC%98%A4%EB%A5%B4%EA%B8%B0/%EA%B3%84%EB%8B%A8%E2%80%85%EC%98%A4%EB%A5%B4%EA%B8%B0.cc)

### 개념 정리
> **DP와 점화식**

    다이나믹 프로그래밍 문제를 풀 때는 항상 점화식을 세우는 것이 매우 중요한 것 같다. 이번 문제 또한 계단을 연속해서 3칸을 밟을 수 없다는 조건과 계단 끝을 항상 밟아야한다는 조건 그렇기에 처음에는 연속 3칸을 밟지 않으며 계단을 처음부터 끝까지 도는 점화식을 찾고있었지만. 계단을 2칸을 뛰는 경우는 i-1 계단을 밟지 않는 경우이고, 역속하는 경우는 i-1칸을 밟는 경우이기 때문에 자연스럽게 i-1의 전은 i-3이 되는 점화식이였습니다.
    *점화식*
    A) [i]+[i-2] : i-1칸을 밟지 않는 경우 = 2칸 점프
    B) [i]+[i-1]+[i-3] : i-1칸을 밟는 경우

    i번째 칸의 최댓값 dp[i]를 구하기 위한 점화식은 
    dp[i] = MAX(A, B)입니다.


> 문제 풀이 과정에서 개선점
    
    점화식을 세운 후에도 값이 이상했는데 배열 순서를 잘못 사용하고 있었다.
    * v : 값 배열
    * dp : dp[i]까지의 최대값 배열
    A는 v[i]+dp[i-1] 순서로 값 배열과 이전 값을 가지고 있는 dp 배열을 더해야했는데
    dp[i]+dp[i-1] 이런 식으로 더해서 값 변경이 없는 오류를 계속 겪었다. 

    다이나믹 프로그래밍에서 어디서 값이 변하는가? 와 이전 값은 어떤 것인가? 위주로 생각을 해야할 것 같다.
### 총평
> 점화식을 세우는 것에 조금 익숙해졌다고 느꼈는데 아직 인것 같다. 

### 참고 자료
> 

---

## 5주차 05번 문제 BOJ 12865번

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/12865

### 문제 풀이
> [백준/Gold/12865. 평범한 배낭/평범한 배낭.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/716ee9c18cc51d25239348b3a63b2be91fe157b9/%EB%B0%B1%EC%A4%80/Gold/12865.%E2%80%85%ED%8F%89%EB%B2%94%ED%95%9C%E2%80%85%EB%B0%B0%EB%82%AD/%ED%8F%89%EB%B2%94%ED%95%9C%E2%80%85%EB%B0%B0%EB%82%AD.cc)

### 개념 정리
> **점화식에서 반복문의 순서를 미리 설계하자**

    반복된 DP 문제 풀이로 그나마 점화식 세우기에 익숙해져있었지만 이번 문제는 점화식까지는 빠르게 세우고 접근했습니다. 
    
    문제 자체가 배낭 알고리즘 문제로 저번에 풀었던 호텔 문제와 비슷하였기에 접근은 빠르게 가능하였지만, 생각과 다르게 답이 계속 틀리게 나왔습니다. 
    
    그 이유로는 for문의 조건을 반대로 사용해서 였습니다. dp[i] 일때 최대 무게를 구하기 위해서는 각 아이템을 하나씩 사용해서 무게에 대한 가치를 확인해보아야하기에 아이템이 외부 for문 무게가 내부 for문 이여야 합니다.
``` C++
    // 점화식
    for(i=0;i<아이템 개수; ++i){
        w=[i]번째 아이템 무게
        v=[i]번째 아이템 가치
        // j가 최대 무게에서 현재 무게로 역방향 반복인 이유
        // * [i]번째 아이템으로 갱신된 값이 dp[j]
        // * 갱신되기 전 [i-1] 순서인 dp[j-w]의 상태와 비교하기 위해
        for(j=최대 무게;j>=w;--j){
            dp[j] = MAX(dp[j], dp[j-w]+v)
        }
    }
```

> 문제 풀이 과정에서 개선점
    
    점화식을 사용 할 때에는 "내가 구해야하는 값" 에 대해서 정확하게 파악해야 반복문을 정확히 사용 할 수 있을 것 같다.

### 총평
> 점화식은 세웠지만 반복 조건을 구하지 못해 GPT에서 도움을 받았다. 아직 DP가 너무 어렵다.

### 참고 자료
> 

---

### 주차 review
> 가장 어려웠던 문제: BOJ 1106 "호텔"
- 이유: DP가 아직 적응되지 않아서 점화식 자체를 세우는데 많은 어려움이 있었고, DP인지 파악하고 그에 해당하는 점화식을 세우는것이 DP에서는 가장 중요하다는 것을 배우게된 문제 였습니다.

> 새로이 알게된 알고리즘 : DP
