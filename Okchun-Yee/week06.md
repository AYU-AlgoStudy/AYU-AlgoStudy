## 6주차 01번 문제 BOJ 2156

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/2156

### 문제 풀이
> [백준/Silver/2156. 포도주 시식/포도주 시식.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/dea47773f8295dea53206ba8599caad419c11415/%EB%B0%B1%EC%A4%80/Silver/2156.%E2%80%85%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D/%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D.cc)

### 개념 정리
> **DP에서 dp[i]를 꼭 포함하지 않아도 되는 경우에 대한 정리**

    문제를 처음 보았을 때에는 계단 오르기 문제가 바로 생각이 들었다. 그래서 계단 오르기 방식으로 바로 접근했고 값이 1차이 났지만 이것은 dp 탐색의 max값을 사용해서 해결하는 듯 했지만 계속해서 오답이 발생했다. 

    원인은 바로 "dp[i]"를 필수로 포함할 필요가 없는 것이였다.
    "계단 오르기" 문제의 경우 마지막 계단을 꼭 밟아야하는 조건이 있으므로 dp[i]를 건너 뛸 수 없었다.
    그러나 "포도주 시식" 문제의 경우 마지막 잔을 꼭 마셔야하는 조건이 없으므로 특정 dp[i]는 건너뛰는 것이 오히려 더 큰 결과를 가져오는 상황인 것이다. 
``` C++
    // 의사코드
    void slove(){
        vector<int> dp(N + 1, 0);
        // 1. BaseCase 설정
        N == 1일 때 dp[1]=v[1]
        N >= 2일 때 dp[2]=dp[1]+v[2]
        // 2. DP 점화식 반복문
        3가지 경우
        case-1. i-1 방문하지 않음=dp[i-2]+v[i]
        case-2. i-1 방문하는 경우=dp[i-3]+v[i-1]+v[i]
        case-3. i   방문하지 않음=dp[i-1]

        // 4. 최종 결과 상정
        3가지 경우 중 가장 큰 값을 dp[i]로 저장
        dp[i]=MAX({case-1, case-2, case-3})
    }
    
```

> 문제 풀이 과정에서 개선점
    
    처음에는 바로 계단 오르기 문제와 동일하다고 생각을 하여서 해당 알고리즘을 사용했지만 결과가 조금씩 다르게 나오는 경우가 많았다. 어떠한 값이 더해지지 않는다고 생각을 하였지만 그게 어떤 값인지? 에 대한 파악은 바로 하지 못한 점이 아쉬웠다. 계단 오르기 문제를 풀었던 과정에 대해서 살펴보다가 [i]를 건너뛰는 경우를 포함해야한다는 것을 알게 되었고 풀 수 있던 문제였다.

### 총평
> 각 문제에 대해서 어떠한 경우가 있는가? 에 대한 경우의 수 파악이 중요한 역량인 것 같다.

### 참고 자료
> BOJ 2579 계단오르기
