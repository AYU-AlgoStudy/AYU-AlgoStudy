## 6주차 01번 문제 BOJ 2156

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/2156

### 문제 풀이
> [백준/Silver/2156. 포도주 시식/포도주 시식.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/dea47773f8295dea53206ba8599caad419c11415/%EB%B0%B1%EC%A4%80/Silver/2156.%E2%80%85%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D/%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D.cc)

### 개념 정리
> **DP에서 dp[i]를 꼭 포함하지 않아도 되는 경우에 대한 정리**

    문제를 처음 보았을 때에는 계단 오르기 문제가 바로 생각이 들었다. 그래서 계단 오르기 방식으로 바로 접근했고 값이 1차이 났지만 이것은 dp 탐색의 max값을 사용해서 해결하는 듯 했지만 계속해서 오답이 발생했다. 

    원인은 바로 "dp[i]"를 필수로 포함할 필요가 없는 것이였다.
    "계단 오르기" 문제의 경우 마지막 계단을 꼭 밟아야하는 조건이 있으므로 dp[i]를 건너 뛸 수 없었다.
    그러나 "포도주 시식" 문제의 경우 마지막 잔을 꼭 마셔야하는 조건이 없으므로 특정 dp[i]는 건너뛰는 것이 오히려 더 큰 결과를 가져오는 상황인 것이다. 
``` C++
    // 의사코드
    void slove(){
        vector<int> dp(N + 1, 0);
        // 1. BaseCase 설정
        N == 1일 때 dp[1]=v[1]
        N >= 2일 때 dp[2]=dp[1]+v[2]
        // 2. DP 점화식 반복문
        3가지 경우
        case-1. i-1 방문하지 않음=dp[i-2]+v[i]
        case-2. i-1 방문하는 경우=dp[i-3]+v[i-1]+v[i]
        case-3. i   방문하지 않음=dp[i-1]

        // 4. 최종 결과 상정
        3가지 경우 중 가장 큰 값을 dp[i]로 저장
        dp[i]=MAX({case-1, case-2, case-3})
    }
    
```

> 문제 풀이 과정에서 개선점
    
    처음에는 바로 계단 오르기 문제와 동일하다고 생각을 하여서 해당 알고리즘을 사용했지만 결과가 조금씩 다르게 나오는 경우가 많았다. 어떠한 값이 더해지지 않는다고 생각을 하였지만 그게 어떤 값인지? 에 대한 파악은 바로 하지 못한 점이 아쉬웠다. 계단 오르기 문제를 풀었던 과정에 대해서 살펴보다가 [i]를 건너뛰는 경우를 포함해야한다는 것을 알게 되었고 풀 수 있던 문제였다.

### 총평
> 각 문제에 대해서 어떠한 경우가 있는가? 에 대한 경우의 수 파악이 중요한 역량인 것 같다.

### 참고 자료
> BOJ 2579 계단오르기

---

## 6주차 2번 문제 BOJ 

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/1405

### 문제 풀이
> [백준/Gold/1405. 미친 로봇/미친 로봇.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/670d764a0ec7c0ff1c5f6a205d2463f8f2aa8b59/%EB%B0%B1%EC%A4%80/Gold/1405.%E2%80%85%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87/%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87.cc)

### 개념 정리
> **백트래킹의 활용에 대해서**

    이 문제를 처음 파악했을 때에는 어떠한 방식으로 탐색은 해야하는가? 에 대한 감도 잡지 못했다. 그렇기에 백준 질문들을 돌아보면서 힌트를 얻었다.

    예상외로 문제는 간단했다. 방문 검사와 매개변수로 확률을 누적 시키는 단순한 문제였다.
``` C++
    // 의사코드

    N = 목표 이동 횟수 (총 레벨)
    answer = 최종 결과
    visited[][] = 2차원 방문 배열
    dr[] = {행 이동 값 4개}
    dc[] = {열 이동 값 4개} 
    dir[] = {4방향 확률}

    void DFS(r, c, 탐색레벨, 누적확률):
        // 1. BaseCase
        if 탐색레벨이 == N에 도달하는 경우:
            answer += 누적확률
            return
        // 2. Do) 방문 처리
        visited[r][c]=true
        // 3. 재귀) 연결된 4방향을 탐색
        for(i=0;i<4;++i):
            다음 r = dir[i]+r
            다음 c = dir[i]+c
            if nr, nc 범위 검사:
                if visitrd[nr][nc] 방문 검사:
                    DFS(nr, nc, 탐색레벨+1, 누적확률*dir[i])
        // 4. Undo) 방문 철회
        visited[r][c]=false

```

> 문제 풀이 과정에서 개선점
    Ex

### 총평
>

### 참고 자료
> 
