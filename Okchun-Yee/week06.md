## 6주차 01번 문제 BOJ 2156

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/2156

### 문제 풀이
> [백준/Silver/2156. 포도주 시식/포도주 시식.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/dea47773f8295dea53206ba8599caad419c11415/%EB%B0%B1%EC%A4%80/Silver/2156.%E2%80%85%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D/%ED%8F%AC%EB%8F%84%EC%A3%BC%E2%80%85%EC%8B%9C%EC%8B%9D.cc)

### 개념 정리
> **DP에서 dp[i]를 꼭 포함하지 않아도 되는 경우에 대한 정리**

    문제를 처음 보았을 때에는 계단 오르기 문제가 바로 생각이 들었다. 그래서 계단 오르기 방식으로 바로 접근했고 값이 1차이 났지만 이것은 dp 탐색의 max값을 사용해서 해결하는 듯 했지만 계속해서 오답이 발생했다. 

    원인은 바로 "dp[i]"를 필수로 포함할 필요가 없는 것이였다.
    "계단 오르기" 문제의 경우 마지막 계단을 꼭 밟아야하는 조건이 있으므로 dp[i]를 건너 뛸 수 없었다.
    그러나 "포도주 시식" 문제의 경우 마지막 잔을 꼭 마셔야하는 조건이 없으므로 특정 dp[i]는 건너뛰는 것이 오히려 더 큰 결과를 가져오는 상황인 것이다. 
``` C++
    // 의사코드
    void slove(){
        vector<int> dp(N + 1, 0);
        // 1. BaseCase 설정
        N == 1일 때 dp[1]=v[1]
        N >= 2일 때 dp[2]=dp[1]+v[2]
        // 2. DP 점화식 반복문
        3가지 경우
        case-1. i-1 방문하지 않음=dp[i-2]+v[i]
        case-2. i-1 방문하는 경우=dp[i-3]+v[i-1]+v[i]
        case-3. i   방문하지 않음=dp[i-1]

        // 4. 최종 결과 상정
        3가지 경우 중 가장 큰 값을 dp[i]로 저장
        dp[i]=MAX({case-1, case-2, case-3})
    }
    
```

> 문제 풀이 과정에서 개선점
    
    처음에는 바로 계단 오르기 문제와 동일하다고 생각을 하여서 해당 알고리즘을 사용했지만 결과가 조금씩 다르게 나오는 경우가 많았다. 어떠한 값이 더해지지 않는다고 생각을 하였지만 그게 어떤 값인지? 에 대한 파악은 바로 하지 못한 점이 아쉬웠다. 계단 오르기 문제를 풀었던 과정에 대해서 살펴보다가 [i]를 건너뛰는 경우를 포함해야한다는 것을 알게 되었고 풀 수 있던 문제였다.

### 총평
> 각 문제에 대해서 어떠한 경우가 있는가? 에 대한 경우의 수 파악이 중요한 역량인 것 같다.

### 참고 자료
> BOJ 2579 계단오르기

---

## 6주차 2번 문제 BOJ 1405

### 🔗| 문제 Link
> https://www.acmicpc.net/problem/1405

### 문제 풀이
> [백준/Gold/1405. 미친 로봇/미친 로봇.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/670d764a0ec7c0ff1c5f6a205d2463f8f2aa8b59/%EB%B0%B1%EC%A4%80/Gold/1405.%E2%80%85%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87/%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87.cc)

### 개념 정리
> **백트래킹의 활용에 대해서**

    이 문제를 처음 파악했을 때에는 어떠한 방식으로 탐색은 해야하는가? 에 대한 감도 잡지 못했다. 그렇기에 백준 질문들을 돌아보면서 힌트를 얻었다.

    예상외로 문제는 간단했다. 방문 검사와 매개변수로 확률을 누적 시키는 단순한 문제였다.
``` C++
    // 의사코드

    N = 목표 이동 횟수 (총 레벨)
    answer = 최종 결과
    visited[][] = 2차원 방문 배열
    dr[] = {행 이동 값 4개}
    dc[] = {열 이동 값 4개} 
    dir[] = {4방향 확률}

    void DFS(r, c, 탐색레벨, 누적확률):
        // 1. BaseCase
        if 탐색레벨이 == N에 도달하는 경우:
            answer += 누적확률
            return
        // 2. Do) 방문 처리
        visited[r][c]=true
        // 3. 재귀) 연결된 4방향을 탐색
        for(i=0;i<4;++i):
            다음 r = dir[i]+r
            다음 c = dir[i]+c
            if nr, nc 범위 검사:
                if visitrd[nr][nc] 방문 검사:
                    DFS(nr, nc, 탐색레벨+1, 누적확률*dir[i])
        // 4. Undo) 방문 철회
        visited[r][c]=false

```

> 문제 풀이 과정에서 개선점
    
    백트래킹 문제를 오랫만에 접하니 원리 자체를 잊은 듯한 느낌을 받았다. 문제에 말이 어려웠어도 본질을 구해야하는 값에 대한 본질을 파악했으면 빠르게 해결 했을 듯한 문제

### 총평
> 하나의 알고리즘을 풀다 보면 이전 알고리즘은 잊는 듯 한 기분이다 기록을 조금 더 자세히 하면서 기억해야겠다.

### 참고 자료
> https://www.acmicpc.net/board/view/35235

---

## 6주차 03번 문제 BOJ 2302

### 🔗| 문제 Link
> (https://www.acmicpc.net/problem/2302) 


### 문제 풀이
> [백준/Gold/2302. 극장 좌석/극장 좌석.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/7c608014ff4399617cdc5a21a491a47be2285601/%EB%B0%B1%EC%A4%80/Gold/2302.%E2%80%85%EA%B7%B9%EC%9E%A5%E2%80%85%EC%A2%8C%EC%84%9D/%EA%B7%B9%EC%9E%A5%E2%80%85%EC%A2%8C%EC%84%9D.cc)

### 개념 정리
> **점화식: 피보나치 수열**

    1) DP 문제를 많이 풀어보면서 드는 생각은 점은 역시 점화식을 어떻게 세울 것인가? 였다. 요즘은 손으로 예제를 하나씩 계산해보면서 점화식에 접근하는 방식이 제일 빠르게 접근하는 것 같다고 생각을 하며 손으로 계산하다보니. VIP석을 기준으로 구간을 나누어서 그 구간별로 경우의 수를 구하고 전부 곱하면 된다는 점화식을 세울 수 있었다.

    2) 각 구간별 경우의 수 점화식
        - VIP석 사이에 일반석이 3자리 있는 경우: A/B/C, B/A/C, A/C/B 이렇게 3가지가 존재한다.
        - VIP석 사이에 일반석이 2자리 있는 경우: A/B, B/A 2가지 경우의 수가 존재한다.
        - 한자리인 경우에는 1이기 때문에 F[3]=F[2]+F[1] => F[N]=F[N-1]+F[N-2]
        즉 피보나치 수열이 만들어진다. 

    3) 이렇게 모든 경우의 수에 대한 피보나치 수열을 만들었고 이제 다음 고민은 "어떻게 VIP 좌석 기준으로 나누지?" 에 대한 고민이였다. 이 부분은 블로그의 도움을 받아서 해결하였습니다.
    
    start = 0부터 vip[i]로 갱신
    end = vip[0] 부터 vip[M] 까지
    `index = vip 위치 - 시작 지점 - 1` 각 vip 좌석 사이마다 해당 인덱스 계산식으로 각 좌석 사이의 길이의 피보나치 수열을 곱하기.


> 문제 풀이 과정에서 개선점
    
    그동안 풀었던 문제들은 대부분 dp[i]가 정답이 였다 그러나 이번문제는 dp[i]가 바로 정답이 아닌 dp 배열은 그저 피보나치 수열 계산 용도로 사용하고 좌석 길이를 파악하는게 핵심인 문제였다. 요즘들어 문제의 의중을 파악하는게 더욱 어려워진 기분이다. 

### 총평
> 문제의 핵심을 파악하는 능력을 더욱 길려야겠다. 무작정 알고리즘부터 적용해서 푸는 것이 아니고 어떤것이 정답인가?를 알아내는 능력이 필요하다.

### 참고 자료
> https://yabmoons.tistory.com/550

---

## 6주차 04번 문제 POS "조이스틱"

### 🔗| 문제 Link
> https://school.programmers.co.kr/learn/courses/30/lessons/42860

### 문제 풀이
> [프로그래머스/2/42860. 조이스틱/조이스틱.cpp](https://github.com/Okchun-Yee/CodingTestStudy/blob/18e7ddeb8c8948634bf797c81f5ce31a0a653920/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/2/42860.%E2%80%85%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1/%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1.cpp)

### 개념 정리
> **그리디 알고리즘의 정의**

    문제의 핵심은 2가지였다. 각 알파벳의 횟수 계산 + 좌우 이동 횟수 계산
    1) 알파벳 횟수 계산
        - 알파벳 배열에서 해당 알파벳의 위치 탐색: idx
        - idx - 'A' 와 'Z' - idx의 최솟값 비교
            * 'Z' - idx는 원래 + 1 연산이 필요하지만 배열.end()로 계산하면 생략
    
    2) (1)의 결과에 이동 횟수를 더하면 되었지만 이동횟수를 구하는 부분에서 어려움을 겪었고, 친구의 도움으로 해결 할 수 있었다.
        - case1: 오른쪽 시작 후 U턴 하는 경우
        - case2: 왼쪽 시작 후 U턴 하는 경우

        length = mina(case1, case2)
``` C++
    // 이동 횟수 구하는 의사코드
    length = 문자열 길이 - 1
    for(i=0;i<문자열 길이;++i):
        next = i+1
        while(next<문자열 길이&&다음 문자가 'A' 인 경우):
            next++
        // 1. case1: 오른쪽 진행 후 U턴 = 현재위치*2 + 문자열 길이-'A'의 수
        case1 = min(length, i*2+n-next)
        // 2. case2: 왼쪽 진행 후  U턴 = (문자열 길이-'A'의 수)*2 + 현재위치
        case2 = min(length, (n-next)*2+i)
        // 3. 최종결과
        length = min(case1, case2)
```

> 문제 풀이 과정에서 개선점
    
    이동 횟수 구하기에서 매우 어려움을 겪었다. 이 문제도 직전의 극장 좌석 문제처럼 A를 벽으로 생각하고 우회하는 경우와 직진하는 경우의 차이라는 것을 알았으면 해결책이 보였을 것 같은 문제였다. 아직 문제 파악이 어려운 것 같다.

### 총평
> 문제 파악이 아직 어렵다.

### 참고 자료
> 

---

## 6주차 05번 문제 BOJ 18243

### 🔗| 문제 Link
> (https://www.acmicpc.net/problem/18243) 

### 문제 풀이
> [백준/Silver/18243. Small World Network/Small World Network.cc](https://github.com/Okchun-Yee/CodingTestStudy/blob/cbebc681d554d80735ce5bf339f2bb1319d33565/%EB%B0%B1%EC%A4%80/Silver/18243.%E2%80%85Small%E2%80%85World%E2%80%85Network/Small%E2%80%85World%E2%80%85Network.cc)

### 개념 정리
> **최단거리와 행렬**

    전형적인 BFS 문제였다. 모든 노드에서 서로 이어져있는 경로를 파악해야하는 문제였기에, 단순하게 최단 경로 표시를 1차원 백터로 하지 않고 2차원 백터로 모든 노드의 모든 경로의 길이를 파악해야하는 문제였다.


> 문제 풀이 과정에서 개선점
    
    BFS 접근은 빨랐다, 다만 이차원 백터로 dist로 사용할때 최단거리 갱신이 계속 안되는 문제가 있었는데 이는 visited 배열을 매 BFS 호출마다 초기화하지 않아서 문제가 발생한 것 이였다. 

### 총평
> BFS 접근이 빨랐다, 다음부터는 BFS 같은 단순 탐색은 골드 이상만 풀어도 될 것 같았다.

### 참고 자료
> 

---

### 주차 review
> 가장 어려웠던 문제 : BOJ 1405
- 답을 알게 되었을 때는 어렵지 않은 문제였지만, 풀이 중에는 너무 어려웠다. 백트래킹을 오랫만에 접해서 그런지 접근 방식 생각을 아예 떠올리지 못했다.

> 새로이 알게된 알고리즘 : DP 점화식 세우기는 할때마다 새롭다
