## 2주차 1번 문제 백준 1182번

🔗| 문제 Link
https://www.acmicpc.net/problem/1182

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/493d4fca87b0bf47ce1fafb2b1ccd4e16bde09eb

### 개념 정리
백트래킹의 개념을 사용할떄의 어디에서 결과를 조회 전달 할 것인지를 명확하기 못하다는 것을
해당 문제를 풀면서 알게 되었습니다.

재귀적으로 dfs를 사용을 할때 아래 구조를 잡아야 한다는 것을 관련 문제들을 해결하면서 느꼈습니다.
```
void dfs(현재 상태) {
	// 2. 종료 조건에 도달했는가?
	if (종료 조건) {
		// 정답 처리 로직
		return;
	}

	// 3. 선택지들을 순회
	for (모든 다음 선택지) {

		// 4. 제약 조건에 맞는가?
		if (후보 조건에 만족하는 선택지인가?) {

			// 5-1. 선택
			상태 변경 (visited = true 등);

			// 5-2. 탐색 (다음 단계로 재귀 호출)
			dfs(다음 상태);

			// 5-3. 선택 취소 (가장 중요!)
			상태 복구 (visited = false 등);
		}
	}
}

```

### 총평
백트래킹의 개념을 익힐 수 있는 문제였지만 아직 관련 지식이 부족하여 다른 문제들을 추가로 더 풀면서 
고민을 할 필요가 있다고 느꼈습니다.

### 참고자료

백준의 다양한 N과 M 문제를 풀면서 위에서 설명한 의사 코드의 스켈레톤 부분을 잡은 것 같아요
백준 15629 ~ 15652 까지 풀면서 기초를 다지기 위해 노력했습니다.

---

## 2주차 2번 문제 백준 1759번

🔗| 문제 Link
https://www.acmicpc.net/problem/1759

### 문제 풀이

https://github.com/zldzldzz/Algorithm/commit/3288cb7d1c990c3a1d251915e3170f1446a7310c

### 개념 정리
모음을 갖는 리스트를 선언하고 해당 리스트에 포함된 수를 반복문을 통해서 체크하고
조건을 통해서 암호 조건에 만족을 하는지 선언하여 사용하였습니다.

처음 문제를 풀때 암호를 만들때 마다 정렬을 해서 극한의 비효율이 발생했었습니다.
처음 정렬을 한 상태로 문제를 시작하면 정렬의 수를 줄일 수 있는 것을 

### 총평
코드의 실행 순서를 고려하여 작성해야 한다는 것을 다시 한번 경험했다.

---

## 2주차 3번 문제 백준 1987번

🔗| 문제 Link
https://www.acmicpc.net/problem/1987

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/867d62dcf22b26426be8ce94b182e686170d55b1

### 개념 정리
visited을 26자리로 만들어 알파벳 중 어디에 도착했는지 확인하고 되돌리는 단순 백트래킹 문제라고 할 수 있었지만
아직 개념과 기초를 명확하게 잡지 못해 오랜 시간이 걸렸다. 위에서 정의한 백트래킹 의사 코드를 더 생각하고 문제를
풀면 좋을 것 같다.

### 총평

아직 백트레킹의 개념이 부족하다고 다시 한번 느끼게 되었다.

