## 3주차 1번 문제 BOJ 18430번
🔗| 문제 Link

https://www.acmicpc.net/problem/18430

### 문제 풀이
https://github.com/zldzldzz/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Gold/18430.%E2%80%85%EB%AC%B4%EA%B8%B0%E2%80%85%EA%B3%B5%ED%95%99

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

    문제를 만났을 때는 기존의 구현 방식을 통해 쉽게 문제를 해결할 수 있다고 생각했다.
    하지만 날개를 2가지 선택할때 어떤 방식이 너무 어렵다고 느꼈다. 그래서 옆에서 같이 있던 친구(한채훈)의 조언
    날개의 위치를 별도로 저장하는 방식으로 해결하라는 것을 통해 날개의 좌표 보정을 별도로 저장하고 연산하는 방식을 배웠다.
    지금까지 배운 백트래킹 방식을 활요하는 새로운 방식을 익힐 수 있었다.

### 총평
백트래킹 경우의 수를 미리 고려하는 것을 배웠다.

--- 

## 3주차 2번 문제 BOJ 16571번

🔗| 문제 Link

https://www.acmicpc.net/problem/16571

### 문제 풀이
https://github.com/zldzldzz/Algorithm/blob/main/%EB%B0%B1%EC%A4%80/Gold/16571.%E2%80%85%EC%95%8C%ED%8C%8C%E2%80%85%ED%8B%B1%ED%83%9D%ED%86%A0/%EC%95%8C%ED%8C%8C%E2%80%85%ED%8B%B1%ED%83%9D%ED%86%A0.java#L47

### 개념 정리
**백트래킹 상태복원과 재귀 종료 시점에 따른 출력 정리**
 
문제 풀이 과정에서 개선점

    현재 상태와 누구의 차례인지 보내면 승패를 알려주는 조건을 만들고
    실제 틱택토가 돌아가는 메서드를 만들었다. 승리와 패배, 무승부
    사이의 우선 순위 선정을 결정하지 못해서 틀렸었다.

### 총평
    함수를 더 나눠서 진행한다면 다 쉽게 문제를 해결할 수 도 있을 것 같다.

---

## 3주차 3번 문제 BOJ 14501번

🔗| 문제 Link

https://www.acmicpc.net/problem/14501

### 문제 풀이
https://github.com/zldzldzz/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/14501.%E2%80%85%ED%87%B4%EC%82%AC

### 문제 풀이 과정에서 개선점

    재귀 탐색을 돌면서 분기적으로 반복을 통해서 최대 값을 비교해서 넘긴다.
    시험기간을 생각해서 비교적 간단한 문제를 선정했지만 마지막 날짜와 반복문 조건을 
    제대로 선정하지 못해서 틀렸다. 인덱싱과 요구사항의 필요한 요소간의 이해가 문제를 풀이하면서
    더 신경써야 할 부분인 것 같다.

### 총평
브루트 포스를 이용해 빠르게 접근한 문제였다.

---

## 3주차 4번 문제 BOJ 15654번

🔗| 문제 Link

https://www.acmicpc.net/problem/15654

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/eefb57b6f8a953c3170d8bc02fe5a4617a12d028

### 개념 정리
```java
void dfs(현재 상태) {
    // 2. 종료 조건에 도달했는가?
    if (종료 조건) {
        // 정답 처리 로직
        return;
    }

    // 3. 선택지들을 순회
    for (모든 다음 선택지) {
        
        // 4. 제약 조건에 맞는가?
        if (유망한 선택지인가?) {
            
            // 5-1. 선택
            상태 변경 (visited = true 등);
            
            // 5-2. 탐색 (다음 단계로 재귀 호출)
            dfs(다음 상태);
            
            // 5-3. 선택 취소 (가장 중요!)
            상태 복구 (visited = false 등);
        }
    }
}
```
    위에 코드 방식을 잊어서 다시 찾아 보고 만들었다.
    또한 종료 조건을 착각해서 여러번 종료 코드를 수정하고 반복 문의 조건도 수정해야 했다.

문제 풀이 과정에서 개선점
    오랫만에 풀어도 감을 잃지 말자

### 총평
시험 기간이라 간단한 문제도 안 풀었다니.. 반성해

---

## 3주차 5번 문제 BOJ 2503번

🔗| 문제 Link

 https://www.acmicpc.net/problem/2503

### 문제 풀이
https://github.com/zldzldzz/Algorithm/tree/main/%EB%B0%B1%EC%A4%80/Silver/2503.%E2%80%85%EC%88%AB%EC%9E%90%E2%80%85%EC%95%BC%EA%B5%AC

### 개념 정리
**브루트 포스 전체 탐색 개념**

    용의자-단서-생존자 방식을 처음 만났고 이것을 문제를 해결하지 전에 전달 들어서 문제를 비교적 빠르게 도전했다.
    하지만 감기 때문인지 오랫만에 풀어서인지 생각이 도저히 돌지 못해서 친구의 코드(C/C++)를 먼저 보고 분석해서 나만의 코드(java)로
    안 보고 다시 만들었다.

문제 풀이 과정에서 개선점

    처음 문제를 보았을 때는 용의자라는 개념 자체를 생각하지 못해서 전체 경우에서 제외한다는 접근 자체를 할 수 없었다.    

### 총평
    스트라이크 볼의 개념을 익히고 용의자를 알고 있다면 쉽게 해결할 수 있지만 나의 경우에는 해결하지 못했다.
    실버 문제도 역시 쉽지 않다.

### 주차 review
제일 어려웠던 문제 : BOJ  2503번
- 이유 : 숫자 야구에서 볼/스트라이크 판별에 대한 개념을 생각하면서 시간을 소모하고 용의자가 모든 단서를 전부 통과해야하는건데 해당 구현 부분을 생각하지 못함.

새로이 알게된 알고리즘 : 용의자-단서-생존자