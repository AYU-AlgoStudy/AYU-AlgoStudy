## 5주차 1번 문제 BOJ 11779번
🔗| 문제 Link
https://www.acmicpc.net/problem/11779

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/f7c34c6118f12b35c0ca32c73bc0d7bd9dd6706a

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**
    이전의 풀었던 문제 접근이지만 이번 문제를 풀때에는 다익스트라 알고리즘을 생각하지 못했다.
    다익스트라 알고리즘을 사용하는 조건은 가중치가 음수가 아닌 간선들로 이뤄진 그래프에서 단일 시작점으로부터
    다른 모든 정점까지의 최단 경로 찾는 것이다.

해당 문제 풀이 설명
    작동 방식:
        1. 초기화: 시작점의 최단 거리는 0으로, 나머지 모든 정점의 최단 거리는 무한대로 설정
        2. 우선순위 큐 (Priority Queue) 사용: 현재까지 알려진 최단 거리가 가장 짧은 정점을 선택하기 위해 사용. -> 큐에서 정점을 하나씩 꺼내면서 주변 정점들을 확인
        3. 이완 (Relaxation): 현재 정점을 거쳐서 다른 인접 정점으로 가는 거리가, 기존에 알려져 있던 인접 정점의 최단 거리보다 더 짧다면, 그 거리를 업데이트하고 우선순위 큐에 새롭게 추가
        4. 반복: 우선순위 큐가 빌 때까지 이 과정을 반복하면, 배열 dist에는 시작점에서 모든 정점까지의 최단 거리가 저장

우선순위 큐 (PriorityQueue)의 사용
    큐에는 {거리, 정점} 형태의 배열 long[]을 넣고, 거리를 기준으로 오름차순 정렬되도록 Comparator.comparing(a -> a[0])를 사용하여 설정
    가장 거리가 짧은 정점(아직 최단 거리가 확정되지 않은 정점 중)이 항상 큐의 맨 앞에 오게 되어, O($\log N$)의 시간 복잡도

경로 역추적을 해결하지 못해서 블로그를 참고하게 되었다.
    경로 역추적 (Path Reconstruction)배열: 
    - int[] route역할: 최단 거리를 계산하는 과정에서 실제로 최단 경로를 구성했던 직전 정점을 저장
    - route[end] = start는 end 도시로 가는 최적의 경로는 start 도시에서 출발했다는 것을 의미
    - 경로 출력: 도착 도시(vEnd)부터 시작하여 route 배열을 따라 역방향으로 추적
    - while (current != 0) 반복문을 사용하여 current = route[current]로 계속 직전 정점을 따라가며 경로를 ArrayList<Integer> routes에 저장
    - 마지막에 이 리스트를 역순으로 출력하여 시작 도시 도착 도시의 경로를 올바르게 표시

### 참고 자료
https://moonsbeen.tistory.com/239

### 총평
이번 경험을 통해 앞으로의 다익스트라 문제를 해결할 초석을 만든 것 같다. 
또한 역추적 알고리즘을 생각하지 못했지만 블로그를 통해 해결 방법을 찾은 것 같다.

---

## 5주차 2번 문제 BOJ 번
🔗| 문제 Link

### 문제 풀이
url

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

해당 문제 풀이 설명

### 총평

---

## 5주차 3번 문제 BOJ 번
🔗| 문제 Link

### 문제 풀이
url

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

해당 문제 풀이 설명

### 총평

---

## 5주차 4번 문제 BOJ 번
🔗| 문제 Link

### 문제 풀이
url

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

해당 문제 풀이 설명

### 총평

---

## 5주차 5번 문제 BOJ 번
🔗| 문제 Link

### 문제 풀이
url

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

해당 문제 풀이 설명

### 총평

---


### 이번주 총평
