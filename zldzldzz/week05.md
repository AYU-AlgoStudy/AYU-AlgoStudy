## 5주차 1번 문제 BOJ 11779번
🔗| 문제 Link
https://www.acmicpc.net/problem/11779

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/f7c34c6118f12b35c0ca32c73bc0d7bd9dd6706a

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**
    이전의 풀었던 문제 접근이지만 이번 문제를 풀때에는 다익스트라 알고리즘을 생각하지 못했다.
    다익스트라 알고리즘을 사용하는 조건은 가중치가 음수가 아닌 간선들로 이뤄진 그래프에서 단일 시작점으로부터
    다른 모든 정점까지의 최단 경로 찾는 것이다.

해당 문제 풀이 설명
    작동 방식:
        1. 초기화: 시작점의 최단 거리는 0으로, 나머지 모든 정점의 최단 거리는 무한대로 설정
        2. 우선순위 큐 (Priority Queue) 사용: 현재까지 알려진 최단 거리가 가장 짧은 정점을 선택하기 위해 사용. -> 큐에서 정점을 하나씩 꺼내면서 주변 정점들을 확인
        3. 이완 (Relaxation): 현재 정점을 거쳐서 다른 인접 정점으로 가는 거리가, 기존에 알려져 있던 인접 정점의 최단 거리보다 더 짧다면, 그 거리를 업데이트하고 우선순위 큐에 새롭게 추가
        4. 반복: 우선순위 큐가 빌 때까지 이 과정을 반복하면, 배열 dist에는 시작점에서 모든 정점까지의 최단 거리가 저장

우선순위 큐 (PriorityQueue)의 사용
    큐에는 {거리, 정점} 형태의 배열 long[]을 넣고, 거리를 기준으로 오름차순 정렬되도록 Comparator.comparing(a -> a[0])를 사용하여 설정
    가장 거리가 짧은 정점(아직 최단 거리가 확정되지 않은 정점 중)이 항상 큐의 맨 앞에 오게 되어, O($\log N$)의 시간 복잡도

경로 역추적을 해결하지 못해서 블로그를 참고하게 되었다.
    경로 역추적 (Path Reconstruction)배열: 
    - int[] route역할: 최단 거리를 계산하는 과정에서 실제로 최단 경로를 구성했던 직전 정점을 저장
    - route[end] = start는 end 도시로 가는 최적의 경로는 start 도시에서 출발했다는 것을 의미
    - 경로 출력: 도착 도시(vEnd)부터 시작하여 route 배열을 따라 역방향으로 추적
    - while (current != 0) 반복문을 사용하여 current = route[current]로 계속 직전 정점을 따라가며 경로를 ArrayList<Integer> routes에 저장
    - 마지막에 이 리스트를 역순으로 출력하여 시작 도시 도착 도시의 경로를 올바르게 표시

### 참고 자료
https://moonsbeen.tistory.com/239

### 총평
이번 경험을 통해 앞으로의 다익스트라 문제를 해결할 초석을 만든 것 같다. 
또한 역추적 알고리즘을 생각하지 못했지만 블로그를 통해 해결 방법을 찾은 것 같다.

---

## 5주차 2번 문제 BOJ 1106번
🔗| 문제 Link
https://www.acmicpc.net/problem/1106

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/5a7438689f3d518b263d494292d6e3bb39365583

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

    DP 알고리즘을 채택하는 조건에 대해 고민했었다. 이전에는 DP알고리즘이라고 나와있으면 사용했지만 
    실제 사용할때는 내가 직접 판단하고 사용해야 한다고 생각했다. 아래는 내가 생각하는 채택 조건이다.
    1. 원래 문제의 최적 해(Optimal Solution)가 그 하위 문제들의 최적 해를 사용하여 구성될 수 있어야 한다.
    2. 큰 문제를 해결하는 과정에서 동일한 하위 문제가 반복적으로 계산되어야 한다.

해당 문제 풀이 설명
    작동 방식
        1. DP 상태 정의 (State Definition): 문제를 해결하기 위해 필요한 정보가 배열의 의미 어떤 의미인지(DP[i], DP[i][j] 등)를 명확하게 정의
        2. 점화식 도출 (Recurrence Relation): 작은 하위 문제의 해답을 이용하여 더 큰 문제의 해답을 계산하는 수학적 관계식을 만든다.
        3. 기저 조건 설정 (Base Case): 화식을 시작할 수 있는 가장 단순한 하위 문제의 해답을 초기화
        4. 구현 방법 선택: 
                - 하향식 (Top-Down, 메모이제이션): 재귀 호출을 사용하며 계산 결과를 저장(Memoization)
                - 상향식 (Bottom-Up, 테이블링): 반복문(Loop)을 사용하여 작은 문제부터 차례로 계산하고 결과를 DP 테이블에 저장

### 총평

DP에 대한 명확한 결정을 하지 못했는데 지금까지 풀었던 dp 보다 점화식 선택이 어려워서 시간을 많이 소모한 것 같다.

---

## 5주차 3번 문제 BOJ 9095번
🔗| 문제 Link
https://www.acmicpc.net/problem/9095

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/4e0ff28b7057ee26048d9211a4f62493ec3341ac

### 개념 정리

위에 문제에서 정의한 채택 기준을 통해 dp 알고리즘의 사용은 확정했지만 점화식과 기저 조건을 올바르게 선택하지 못해서 
제미나이의 도움을 받았다. 하지만 기저 조건을 만들때 `dp[목표] = 기조 조건으로 시작 가능한 조건`이라는 방식을 배운 것 같다.

### 총평

dp를 이해한줄 알았지만 나의 오만이었다.

---

## 5주차 4번 문제 BOJ 2579번
🔗| 문제 Link
https://www.acmicpc.net/problem/2579

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/28274f2c27822c277832f8945a114c9554dad4b1

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**
아래에서 위로 올라가는 것만 생각하고 위에서 아래를 생각하지 못했다.
계단의 목표칸은 무조건 선택 되기 때문에 바로 아래칸을 선택하면 이전에는 2칸 이전의 칸을 선택했어야하거나 
해당 칸이 2칸을 이동하면 된다는 접근  자체를 생각하지 못해서 문제를 풀지 못했다.


### 총평

dp는 문제를 풀 수록 접근 방식 자체가 틀리니까 너무 어렵다.. 풀다보면 익숙해 진다는 생각으로 꾸준히 풀어야 할 것 같다.

---

## 5주차 5번 문제 BOJ 번
🔗| 문제 Link

### 문제 풀이
url

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**

해당 문제 풀이 설명

### 총평

---


### 이번주 총평
