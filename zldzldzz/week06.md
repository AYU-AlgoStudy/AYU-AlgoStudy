## 6주차 1번 문제 BOJ 2156번

🔗| 문제 Link
[문제 링크](https://www.acmicpc.net/problem/2156)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/0af3f45dc2a03166a3892f3a38d4d08c33ff84f6

### 개념 정리
 이번 문제는 이전의  풀었던 계단 오르기 문제와 같은 문제라고 생각했다 때문에 이전의 작성헀던 코드를 다시 작성하고
 제출을 눌렀지만 바로 `틀렸습니다.`를 만났다. 원인은 현재 층을 담지  않은 경우의 수를 생각하지 못했다.
 위에 같은 차이가 발생하는 이유는 계단 문제는 무조건 마지막 층을 측정하기 때문에 가능했지만 해당 문제의 경우 마지막 층을 
 탐색해야 한다는 조건이 없다.

### 참고 자료
https://github.com/zldzldzz/Algorithm/commit/28274f2c27822c277832f8945a114c9554dad4b1

### 총평
차이점을 생각하는데 너무 오랜 시간이 걸렸다.

---

## 6주차 2번 문제 BOJ 1405번

🔗| 문제 Link
[문제 링크](https://www.acmicpc.net/problem/1405)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/blob/7576249efa67da2954c22e41780f1f333668f146/%EB%B0%B1%EC%A4%80/Gold/1405.%E2%80%85%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87/%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87.java

### 개념 정리

    문제의 풀이를 보면 평범한 백트래킹 문제처럼 보인다. 하지만 확률을 구해야 하는 부분을 생각하지 못하면 아려움을 겪을 수 있다.
    나의 경우 확률에 따른 접근을 하기 위해서 실패 했을 때와 성공했을 때를 나눠서 구하는 방식을 고민 했다.
    하지만 고민과 달리 문제는 점점 더 미궁으로 빠지는 기분이었다.
    결국 문제를 검색해 다른 언어 풀이를 읽고 일반적인 백트래킹 접근이며 성공시 확률을 구하면 된다는 것을 알게 되었다.

### 총평

    오랫만에 백트래킹 문제를 직면해서 문제의 풀이를 시도하는 것도 오래 걸린 것 같다.

---
