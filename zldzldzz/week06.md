## 6주차 1번 문제 BOJ 2156번

🔗| 문제 Link
[문제 링크](https://www.acmicpc.net/problem/2156)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/0af3f45dc2a03166a3892f3a38d4d08c33ff84f6

### 개념 정리
 이번 문제는 이전의  풀었던 계단 오르기 문제와 같은 문제라고 생각했다 때문에 이전의 작성헀던 코드를 다시 작성하고
 제출을 눌렀지만 바로 `틀렸습니다.`를 만났다. 원인은 현재 층을 담지  않은 경우의 수를 생각하지 못했다.
 위에 같은 차이가 발생하는 이유는 계단 문제는 무조건 마지막 층을 측정하기 때문에 가능했지만 해당 문제의 경우 마지막 층을 
 탐색해야 한다는 조건이 없다.

### 참고 자료
https://github.com/zldzldzz/Algorithm/commit/28274f2c27822c277832f8945a114c9554dad4b1

### 총평
차이점을 생각하는데 너무 오랜 시간이 걸렸다.

---

## 6주차 2번 문제 BOJ 1405번

🔗| 문제 Link
[문제 링크](https://www.acmicpc.net/problem/1405)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/blob/7576249efa67da2954c22e41780f1f333668f146/%EB%B0%B1%EC%A4%80/Gold/1405.%E2%80%85%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87/%EB%AF%B8%EC%B9%9C%E2%80%85%EB%A1%9C%EB%B4%87.java

### 개념 정리

    문제의 풀이를 보면 평범한 백트래킹 문제처럼 보인다. 하지만 확률을 구해야 하는 부분을 생각하지 못하면 아려움을 겪을 수 있다.
    나의 경우 확률에 따른 접근을 하기 위해서 실패 했을 때와 성공했을 때를 나눠서 구하는 방식을 고민 했다.
    하지만 고민과 달리 문제는 점점 더 미궁으로 빠지는 기분이었다.
    결국 문제를 검색해 다른 언어 풀이를 읽고 일반적인 백트래킹 접근이며 성공시 확률을 구하면 된다는 것을 알게 되었다.

### 총평

    오랫만에 백트래킹 문제를 직면해서 문제의 풀이를 시도하는 것도 오래 걸린 것 같다.

---

## 6주차 3번 문제 BOJ 2302번

🔗| 문제 Link
[문제 링크](https://www.acmicpc.net/problem/2302)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/02d0b91773efac0249328f6e22d0c08452f31956

### 개념 정리

    처음에 vip를 기준으로 교환을 할 수 없다는 것을 깨달고 생각했다. 이를 통해 vip를 경계로 잡고 계산을 하면 된다는 것은 
    쉽게 떠올렸다. 하지만 여기서 문제는 그 안에서의 교환을 어떤 식으로 경우의 수를 구해야 하는지를 고민했지만 정답을 찾지 못했다.
    때문에 아래의 참고 자료를 읽고 나서 경우의 수가 피보나치 수열로 구할 수 있다는 것을 알았다.

#### 점화식 구하는 과정
    F[N] = F[N - 1] + F[N - 2]
    F[1] 혼자이기 때문에 1
    F[2] 2명이서 바꾸 거나 그대로 가는 경우 2
    F[3] [3고정] 2, 1, 3 / 1, 2, 3  | [3 이동] 1, 3, 2
    이때 F[3]을 보면 3을 제외하면 이전의 F[2]의 경우를 그대로 가져오고 새로운 3만 추가 된것으로 보인다.
    F[4]의 경우 
        - [4를 고정] 1, 2, 3, 4 / 2, 1, 3, 4 / 1, 2, 3, 4
        - [4를 이동] 1, 2, 4, 3 / 2, 1, 4, 3
    위와 같이 생각하면 추가 되는 사람은 고정하고 다른 사람들이 이동하는 경우의 수(F(N-1))와
    새로 추가 된 사람과 마지막의 두번째 사람이 교환을 확정하고 이동하는 경우(F(N-2))라는 것을 도출할 수 있다.

### 참고자료
https://yabmoons.tistory.com/550

### 총평

dp 문제를 잘 푸는 것은 점화식을 잘 세우는 것이 중요하다고 생각한다. 하지만 문제별로 다른 점화식이 각각 달라지는데
여러가지 문제를 푼다고 늘릴 수 있는 것인지에 대한 궁금중이 생겼다.

---

## 6주차 4번 문제 PGS 조이스틱

🔗| 문제 Link
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42860?language=java)

### 문제 풀이
https://github.com/zldzldzz/Algorithm/commit/3025e8d9cdae34b159363ac47998ff6f5e9a095b

### 개념 정리

**문제 풀이 과정에서 개선점 & 배운점**
문제를 이해하는 것 부터가 어려웠다. 위아래는 문제를 금방 해결했지만 좌우의 이동이 무엇인지를 이해하는데 있어서 너무 오랜 시간이 걸렸다.
슬롯머신 같은 것이라는 것을 참고자료를 2가지 모두 읽고 생각을 한 후에 이해했다.
이후에는 왜 A를 기준으로 좌우의 이동을 찾는 것인지를 이해하지 못했다.
A를 기준으로 이동을 결정하는 이유는 A는 변경이 필요 없어도 되기 때문이다. 만약 A가 아닌 문자로만 이뤄져 있다면
한 방향으로만 이동했어도 상관 없을 것이다. 하지만 A가 존재 한다면 A는 좌우로 이동할때의 한번의 추가적인 이동을 하기 때문이었다.

#### 참고자료
https://aiday.tistory.com/120#google_vignette
https://mang-kko.tistory.com/169

### 총평

문제 자체를 이해하지 못하면 문제를 전혀 풀 수 없다는 것을 깨달았다.
알고리즘을 알고 문제를 해결하는 접근도 중요하지만 문제 자체를 이해하지 못하면 문제를 풀 수 없다는 것을 깨달았다.
문제를 이해하는 데만 1시간 30분이나 걸렸다....

---
